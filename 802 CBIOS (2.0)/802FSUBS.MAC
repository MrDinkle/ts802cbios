
; THIS ROUTINE DOES THE ACTUAL SEEKING.

SEEK:	LD	HL,TRKTAB	; CURRENT TRACK TABLE
	LD	A,(HSTDSK)	; CURRENT DRIVE
	LD	C,A		; MAKE IT AN INDEX INTO
	LD	B,0		; TRACK TABLE
	ADD	HL,BC		; ADD IN INDEX
	LD	A,(HL)		; PULL OUT THE TRACK FOR THIS DRIVE
	OUT	(FDCTRK),A	; SEND IT TO THE CONTROLLER
	LD	B,A		; SAVE FOR LATER
	LD	A,(HSTTRK)	; GET THE SOUGHT-AFTER TRACK.
	LD	(HL),A		; PLACE IT IN TRACK TABLE
	CP	B		; SAME TRACK?
	RET	Z		; YES, NO NEED TO SEEK
	OUT	(FDCDAT),A	; AND GIVE IT TO THE CONTROLLER.
	LD	A,SEECMD	; THIS IS THE SEEK COMMAND
	OUT	(FDCCMD),A	; GIVE THE ORDER TO FDC

; NOW TEST FOR COMPLETION

	CALL	WAIT		; WAIT UNTIL NOT BUSY
	AND	SEEMSK		; AND OUT TRACK 0 BIT
	RET			; MAY HAVE FAILED

; THIS ROUTINE LOOPS UNTIL THE FDC IS
; IN A NON-BUSY STATE, OR UNTIL A NOT-
; READY CONDITION IS DETECTED.  TIME-OUT
; FOR DRIVE BUSY OCCURS AT APPROX.
; 1.5 SECONDS AFTER COMMAND
; INITIATION.

WAIT:	LD	A,15		; WE MUST DELAY ABOUT
WAIT10:	DEC	A		; 60 USECS. BEFORE READING 
	JR	NZ,WAIT10	; THE STATUS.

	LD	(TEMPBC),BC	; SAVE REGISTERS
	LD	(TEMPDE),DE
	LD	(TEMPHL),HL
	LD	BC,0C000H	; TIME OUT FOR 1.25 SECONDS
	LD	A,0
	LD	(JMPSW),A	; RESET THE FLAG FOR MESSAGE

WAIT20:	IN	A,(FDCCMD)	; READ THE FDC STATUS--2.75
	LD	(ERFLAG),A	; SAVE IT FOR LATER--3.25
	BIT	FDCRDY,A	; IS THE DEVICE NOT READY?--2.00
	JR	NZ,WAIT50	; YES, THIS IS AN ERROR--1.25

	PUSH	AF		; SAVE REGISTERS--2.75
	LD	A,(JMPSW)	; GET MESSAGE FLAG--3.25
	CP	0		; MESSAGE ALREADY SENT OUT?--1.75
	JR	NZ,WAIT30	; YES, SKIP--1.75
	DEC	BC		; COUNT DOWN--1.50
	LD	A,B		; --2.25
	OR	C		; TIME OUT?--1.00
	CALL	Z,SIGMSG	; YES, PRINT MESSAGE--2.50
WAIT40:	POP	AF		; RESTORE REGISTERS--2.50

	BIT	FDCBSY,A	; ARE WE PROCESSING A COMMAND?--2.00
	JR	NZ,WAIT20	; NO, RETURN ERROR CODE--3.00

	LD	(UNMSTA),A	; UNMASKED STATUS (FOR DEBUG)
	AND	ERRMSK		; MASK OFF NON-ERROR BITS
	LD	(ERFLAG),A	; SAVE STATUS FOR LATER

WAIT50:	LD	HL,(TEMPHL)	; RESTORE REGISTERS
	LD	DE,(TEMPDE)
	LD	BC,(TEMPBC)
	RET

WAIT30:	CALL	CONST		; CONSOLE STATUS
	CP	0		; AVAILABLE INPUT?
	JR	Z,WAIT40	; NO, SKIP
	CALL	CONIN		; GET CHARACTER
	CP	03H		; CONTROL-C?
	JR	NZ,WAIT40	; NO, LOOP BACK

	POP	AF		; RESTORE REGISTERS
	LD	HL,(TEMPHL)
	LD	DE,(TEMPDE)
	LD	BC,(TEMPBC)

	LD	A,FRCCMD	; FORCE TERMINATE
	OUT	(FDCCMD),A
	OUT	(FDCCMD),A
	CALL	RESDMA		; RESET DMA
	LD	A,0
	LD	(DEFDSK),A	; SET DEFAULT DRIVE TO A
	JP	WBOOT		; WARM-BOOT

; THIS ROUTINE PRINTS DOOR MESSAGE WHEN THERE IS AN ACCESS TO
; A DRIVE WITH DOOR OPENED

SIGMSG:	LD	A,1		; SET FLAG
	LD	(JMPSW),A
	LD	A,(HSTDSK)	; CURRENT DRIVE
	ADD	A,41H		; MAKE IT ASCII
	LD	(VDRIVE),A	; SAVE FOR LATER
	LD	HL,RDYMSG	; PRINT DOOR MESSAGE
	CALL	PRTMSG
	RET

; SELECT THE PROPER SIDE OF THE
; DISKETTE TO SEEK, DEPENDING ON
; THE LOGICAL SECTOR NO. IN HSTSEC.
; GO AHEAD AND SET THE FDC SECTOR
; REGISTER.

SELSID:	LD	A,(FDDBYT)	; GET THE DRIVE SELECT LATCH IN MEMORY
	LD	C,A		; HOLD IT IN C FOR A BIT.
	RES	2,C		; CHOOSE SIDE 0, FOR NOW.
	LD	A,(HSTSEC)	; GET THE LOGICAL HOST SECTOR 
	CP	PSPT0		; SECTOR >= THAN MAXIMUM SECTOR?
	JR	C,SELS10	; IF NOT THEN SELECT SIDE 0
	SET	2,C		; CHOOSE SIDE 1.
	SUB	PSPT0		; DE-BIAS SECTOR NO.

SELS10:	INC	A		; PHYSICAL SECTORS HAVE ORIGIN 1
	OUT	(FDCSEC),A	; SEND SECTOR TO CONTROLLER
	LD	(TSEC),A	; SAVE FOR LATER
	LD	A,C		; GET NEW SIDE.
	LD	(FDDBYT),A	; RESTORE IT TO THE MEMORY IMAGE
	OUT	(FDD),A		; AND LATCH
	LD	A,(MOTFLG)	; MOTOR ON-OFF FLAG
	CP	0		; MOTOR OFF?
	RET	NZ		; NO, SKIP DELAY
	LD	A,1
	LD	(MOTFLG),A	; SET MOTOR ON FLAG
	LD	BC,40000	; NEEDS DELAY FOR ABOUT 300MSEC
SELS20:	DEC	BC		; COUNT DOWN
	LD	A,B
	OR	C		; REACHED ZERO YET?
	JR	NZ,SELS20	; NO, LOOP BACK
	RET			; ALL DONE.

; SELECT THE DRIVE IN HARDWARE.
; DRIVE TO BE SELECTED IS PASSED
; IN REGISTER A.

SELDRV:	LD	(HL),A		; SAVE CURRENT DRIVE FOR LATER
	LD	C,00010000B	; THIS IS THE MASK FOR DRIVE 0

SELD10:	OR	A		; HAVE WE GOT THE RIGHT MASK?
	JR	Z,SELD20	; YES.
	SLA	C		; SHIFT DRIVE MASK OVER 1 BIT LEFT.
	DEC	A		; DOWN THE COUNTER.
	JR	SELD10		; AND LOOP.

SELD20:	LD	A,(FDDBYT)	; GET MEMORY IMAGE OF DRIVE LATCH
	AND	00001111B	; AND OFF CURRENT DRIVE SELECT BITS.
	OR	C		; OUT WITH THE OLD, IN WITH THE NEW
	LD	(FDDBYT),A	; RESTORE MEMORY IMAGE.
	OUT	(FDD),A		; AND INFORM LATCH ABOUT NEW DRIVE.
	RET

; RESET THE DISK SUBSYSTEM BY RESTORING
; ALL THE HEADS TO TRACK 0.  RESTORING
; DRIVES IN REVERSE ORDER ASSURES THAT
; DRIVE A WILL ALWAYS BE SELECTED UPON
; COMPLETION.

RESDSK:	LD	A,00000010B	; INITIALIZE THE FDD LATCH, MOTOR ON
	LD	(FDDBYT),A	; MEMORY IMAGE.
	OUT	(FDD),A		; HARDWARE LATCH.
	LD	B,MAXDRV	; INITIAL DRIVE NO.

RESD10:	LD	A,B		; SELECT THE DRIVE
	LD	(HSTDSK),A	; STORE IT IN HSTDSK
	LD	HL,DRIVE
	CALL	SELDRV
	CALL	RESTOR		; RESTORE THE HEADS TO TRACK 0
	DEC	B		; DECREMENT DRIVE NO.
	JP	P,RESD10	; LOOP FOR NEXT DRIVE
	RET

; RESTORE THE HEADS ON THE CURRENTLY
; SELECTED DRIVE TO TRACK 0.  THIS IS
; DONE AFTER EACH SEEK, READ, OR, WRITE
; FAILURE. ALSO AT WARM AND COLD BOOT.
; WE MUST RESET THE CURRENT TRACK FOR
; THIS DRIVE ALSO.

RESTOR:	LD	A,(HSTDSK)	; GET THE CURRENT DRIVE
	LD	HL,TRKTAB	; BASE ADDRESS OF CURRENT TRACK TABLE
	LD	E,A
	LD	D,0		; MAKE DRIVE NO. AN INDEX.
	ADD	HL,DE		; ADD IN INDEX.
	LD	(HL),0		; CLEAR CURRENT TRACK TO 0.
	LD	A,RESCMD	; FDC RESTORE COMMAND
	OUT	(FDCCMD),A	; SEND IT.
	CALL	WAIT		; WAIT FOR COMPLETION
	RET

; RESET THE DMA SIX TIMES TOTAL

RESDMA:	PUSH	BC		; DON'T DESTROY REGGIES
	LD	B,6		; COUNTER
RDMA10:	LD	A,11000011B	; RESET THE DMA
	OUT	(DMA),A		; SO THAT IT DOESN'T RUN ON.
	DJNZ	RDMA10		; LOOP FOR ANOTHER TIME
	POP	BC		; RESTORE REGISTER PAIR
	RET			; ALL DONE

; MISCELANEOUS ROUTINES

; PRINT THE STRING POINTED TO BY HL
; AND TERMINATED BY NULL (0).

PRTMSG:	LD	A,(HL)
	OR	A
	RET	Z		; ALL DONE

	LD	C,A
	CALL	CRTOUT		; OUTPUT IT
	INC	HL
	JR	PRTMSG		; AND LOOP BACK

; GENERAL PORT INITIALIZATION ROUTINE
;	ENTRY:		HL	->	PORT ADDRESS
;					BYTE COUNT
;					DATA
;					 |
;					 |

PRTINI:	LD	C,(HL)		; GET PORT ADDRESS
	INC	HL		
PRTENT:	LD	B,(HL)		; GET THE COUNT
	INC	HL		; POINT TO FIRST DATA BYTE
	OTIR			; BLOCK OUTPUT
	RET

; ADDITIONAL HARWARE SYSTEM 
; HARDWARE INITIALIZATION 
; COMES NEXT.

HDWINI:	CALL	RESDSK		; RESET THE DISK SUBSYSTEM
	LD	HL,SIOTAB	; INITIALIZE SIO #1 FOR SERIAL PRINTER
	CALL	PRTINI		; BAUD RATE IS SET UP IN PROM CODE
				; BY READING THE DIP SWITCH
	RET			; MAY BE MORE LATER

; THIS ROUTINE TRANSFERS CONTROL TO 
; THE I/O DRIVER INDICATED BY THE 
; APPROPRIATE BITS IN IOBYTE (0003H).
; ENTRY:	HL ->	<DEVICE TYPE>
;			<DEVICE 1 ADDRESS>
;			<DEVICE 2 ADDRESS>
;			<DEVICE 3 ADDRESS>
;			<DEVICE 4 ADDRESS>

IODISP:	POP	HL		; GET DISPATCH TABLE POINTER
	PUSH	BC		; SAVE PERTINENT REGISTERS
	PUSH	DE
	LD	A,(HL)		; DEVICE TYPE
	INC	HL		; ADVANCE POINTER
	LD	B,A		; SAVE DEVICE TYPE FOR LATER
	OR	A		; WHICH DEVICE?
	LD	A,(IOBYTE)	; RETREIVE CURRENT IOBYTE
	JR	Z,IODI20	; NO SHIFTING NEEDED

IODI10:	RRA			; ROTATE BYTE UNTIL DEVICE BITS
	DJNZ	IODI10		; ARE LINED UP WITH BIT 0

IODI20:	AND	03H		; MASK OFF DON'T CARE BITS
	RLA			; FORM WORD OFFSET
	LD	C,A		; FORM 16 BITS, B ALREADY 0
	ADD	HL,BC		; ADD IN BASE ADDRESS
	LD	E,(HL)		; TRANSFER DISPATCH ADDRESS
	INC	HL		; TO REGISTERS DE
	LD	D,(HL)
	EX	DE,HL		; RESULT INTO HL
	POP	DE		; RESTORE REGISTERS
	POP	BC
	JP	(HL)		; OFF WE GO, INTO THE WILD BLUE YONDER!

; THIS ROUTINE FILLS OUT THE DETAILED ERROR MESSAGE TABLE
; OBTAINING VARIABLE VALUES FROM CURRENT STATE.
; THEN CALLS PRTMSG ROUTINE WITH THE TABLE ADDRESS IN HL

ERRPRT:	LD	A,(COMAND)	; CURRENT COMMAND
	CP	80H		; READ?
	JR	NZ,WRMSG	; NO, SKIP
	LD	HL,RMSG		; READ MESSAGE
	JR	ERR10
WRMSG:	LD	HL,WMSG		; WRITE MESSAGE
ERR10:	LD	DE,VCMD		; COMMAND MESSAGE ADDRESS IN TABLE
	LD	BC,5
	LDIR			; STORE IN TABLE
	LD	HL,VSIDE	; SIDE VARIABLE
	LD	A,(FDDBYT)	; MEMORY IMAGE
	BIT	2,A		; SIDE BIT
	JR	Z,ONE		; 0 - SIDE 1
	LD	(HL),32H	; ASCII	2
	JR	CONT10
ONE:	LD	(HL),31H	; ASCII 1
CONT10:	LD	HL,VTRK		; TRACK VARIABLE
	LD	A,(HSTTRK)	; CURRENT TRACK NUMBER
	CALL	FTAB		; FILL OUT TABLE ROUTINE
	LD	HL,VSEC		; SECTOR VARIABLE
	LD	A,(TSEC)	; CURRENT TARGET SECTOR
	CALL	FTAB
	LD	HL,VSTAT	; ERROR STATUS
	LD	A,(ERFLAG)	; GET ERROR FLAG
	CALL	FTAB
	LD	HL,ERRMSG	; ERROR MESSAGE TABLE ADDRESS
	CALL	PRTMSG
	RET

; THIS ROUTINE CONVERTS HEX CODE INTO ASCII AND FILL OUT THE TABLE

FTAB:	PUSH	AF		; SAVE REGISTERS
	RRCA			; ROTATE RIGHT 4 TIMES
	RRCA
	RRCA
	RRCA
	CALL	GHEX		; CONVERT HIGH ORDER 4 BITS TO ASCII
	LD	(HL),A		; STORE INTO TABLE
	INC	HL		; NEXT TABLE LOCATION
	POP	AF		; RESTORE REGISTERS
	CALL	GHEX		
	LD	(HL),A		
	RET

; HEX INTO ASCII ROUTINE

GHEX:	AND	0FH		; STRIP HIGH 4 BITS
	CP	10		; NUMERIC?
	JR	NC,G10		; YES, SKIP FOR ALPHA
	ADD	A,'0'		; ADD 30
	RET
G10:	ADD	A,'A'-10	; ADD 40
	RET

; END OF 802FSUBS.MAC

