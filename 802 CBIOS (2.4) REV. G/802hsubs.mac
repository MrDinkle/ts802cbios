	.Z80

;	***********************************************
;	SUBROUTINES TO SUPPORT ALL THE MODULES IN CBIOS
;	***********************************************

;	ADDITIONAL HARDWARE INITIALIZATION

HDWINI:

;	INITIALIZE SIO PORT

	LD	HL,SIOTAB
	CALL	PRTINI		; INITIALIZE SIO CHANNEL A
	CALL	PRTINI		; INITIALIZE SIO CHANNEL B
	IN	A,(SIOBD1)	; EMPTY CH 'A' RCV.-REG
	IN	A,(SIOBD0)	; EMPTY CH 'B' RCV.-REG

;	INITIALIZE MODEM PORT

	LD	HL,MODTAB	; INITIALIZE MODEM PORT
	CALL	PRTINI
	LD	C,CTCP0
	LD	A,CTCM0		; CTC #0 CONTROL REG
	OUT	(C),A
	LD	A,BAUD1		; SET BAUD RATE AS 300
	OUT	(C),A

;	INITIALIZE TIME AND DATE COUNTER

	LD	C,CTCP3
	LD	A,10110101B	; INITIALIZE TIMER
	OUT	(C),A
	LD	A,156		; PRESET TIMER COUNTER
	OUT	(C),A
	LD	HL,CTCI3
	LD	A,L
	AND 	0FEH		; SET TIMER INTERRUPT VECTOR(LSB)
	OUT	(CTCP0),A

	LD	A,10H
	OUT	(SIOBC0),A	; RESET EXT/STATUS LATCH COMMAND
	IN	A,(SIOBC0)
	AND	20H		; CHECK CTS BIT
	LD	A,24H		; CTS+TXMT READY
	JR	Z,XMIT0
	LD	A,0FH		; ENABLE XON/XOFF (^O)
	LD	(PROMPT),A
	LD	A,4
XMIT0:	LD	(CRTMSK),A		
	RET
		 
;	TIMER INTERRUPT SERVICE ROUTINE
;

TCOUNT:	DI
	LD	(TUSTACK),SP	; SAVE USER STACK
	LD	SP,LSTACK	; SET STACK POINTER TO LOCAL
	PUSH	AF
	PUSH	HL
	LD	HL,(MSECNT)
	INC	HL
	LD	(MSECNT),HL	; INCREMENT 16 BIT MS COUNTER
;
;	LD	A,10110101B	; INITIALIZE TIMER
;	OUT	(CTCP3),A
;	LD	A,156		; PRESET TIMER COUNTER (1/100 SEC)
;	OUT	(CTCP3),A
;
	LD	HL,CLOCK
	CALL	TCOUN4		; COUNT 1/100 SEC
	JP	NZ,TEXIT	; SKIP IF NOT OVERFLOW 99(BCD)
;
	CALL	FLOPOFF		; TURN OFF FLOPPY DISK ?
;
TEXIT:	POP	HL
	POP	AF
	LD	SP,(TUSTACK)	; RESTORE USER STACK
	EI
	RETI	 	

TCOUN4:	LD	A,(HL)		; ADD 1 TO NEXT COUNT
	ADD	A,1
	DAA
	LD	(HL),A
	RET
;
;	TURN FLOPPY DRIVES MOTOR OFF?
;
FLOPOFF:
	LD	A,(FDTIME)	; MOTOR OFF DISABLE
	OR	A
	RET	Z
	DEC	A		; TIME = TIME - 1
	LD	(FDTIME),A
	RET	NZ		; EXIT IF NOT TIMEOUT
	XOR 	A
	OUT	(DSELOP),A	; ELSE RESET DRIVE SELECT AND TURN MOTOR OFF
	LD	(FDMOT),A	; SET MOTOR OFF INDICATION
	RET

;	RETURN DE=ADDRESS OF INTERRUPT VECTOR TABLE
;	FOR USER PROGRAM WANT TO USE 16-BIT COUNTER
;	THAT INCREMENT AT EVERY 10 MS THEN
;	DE-2=LSB COUNT, DE-1=MSB COUNT

INTADD:
	LD	DE,INTVEC	; SET DE=INTERRUPT TABLE ADDRESS
	RET 
;
;	8-BITS BINARY DIVISION ROUTINE
;  Divide 16 bit dividend by 8 bit divisor
;  and returns a 16 bit quotient:
;       Entry:  A-reg = divisor
;	       HL-reg = dividend
;       Exit:  HL-reg = quotient
;		A-reg = remainder
;	Uses:   A reg and flags
;	       BC-reg and flags
;	       DE-reg and HL-reg	

DIVIDE:
	LD	C,A		; SAVE DIVISOR INTO C-REG
	LD	B,8		; COUNT = NUMBER OF BITS IN DIVISOR
	LD	DE,0		; CLEAR QUOTIENT REG
DIV:
	ADD	HL,HL		; SHIFT DIVIDEND, QUOTIENT LEFT 1 BIT
	EX	DE,HL
	ADD	HL,HL		; SHIFT QUOTIENT
	EX	DE,HL
	LD	A,H		; CAN DIVISOR BE SUBTRACTED?
;
DIV1:	SUB	C
	JR	C,CNT		; NO, GO TO NEXT STEP
	LD	H,A		; YES, SUBTRACT DIVISOR FROM DIVIDENT
	INC	DE		; ADD 1 TO QUOTIENT
	JR	DIV1
;
CNT:	DJNZ	DIV		; LOOP UNTIL COUNT = 0
	LD	A,H		; A = REMAINDER
	EX	DE,HL		; HL = QUOTIENT
	RET			; RETURN WITH H = REMAINDER; L = QUOTIENT

;
;	DECIMAL CONVERSION SUBROUTINE
;

CVD4:	LD	BC,1000		; 4-DIGIT
	CALL	CVD
CVD3:	LD	BC,100
	CALL	CVD
CVD2:	LD	BC,10
	CALL	CVD
CVD1:	LD	BC,1
	CALL	CVD
	RET

CVD:	XOR	A		; CLEAR A
	EX	DE,HL		; SWAP DE(DATA) FOR HL(OUTPUT POINTER)
CVDL:	OR	A		; CLEAR CARRY FLAG
	SBC	HL,BC		; SUBTRACT BC(POWER OF 10) FROM HL(DATA)
	JP	M,CVDX		; IF RESULT NEGATIVE, EXIT
	INC	A		; POSITIVE, ADD ONE TO RESULT
	JR	CVDL

CVDX:	ADD	HL,BC		; ADD BACK LAST VALUE
	EX	DE,HL		; SWAP BACK DE AND HL
	ADD	A,'0'		; CONVERT RESULT TO ASCII
	LD	(HL),A		; STORE IN OUTPUT AREA
	INC	HL		; BUMP OUTPUT POINTER
	RET			; RETURN TO CALLER

;
;	PRINT ROUTINE
;

PRNT:	LD	A,(HL)		; PRINT CHAR
	INC	HL		; FOR NEXT CHAR
	OR	A
	RET	Z		; RIF DONE
	LD	C,A
	PUSH	HL
	CALL	CONOUT		; PRINT A CHAR
	POP	HL
	JR	PRNT		; DO NEXT CHAR

;	CARRIAGE RETURN, LINE FEED

CRLF:	LD	C,CR
	CALL	CONOUT		; PRINT A CR
	LD	C,LF
	JP	CONOUT		; PRINT A LF, EXIT

;
; 	THIS ROUTINE CONVERTS HEX CODE INTO ASCII AND FILL OUT THE TABLE
;

FTAB:	PUSH	AF		; SAVE REGISTERS
	RRCA			; ROTATE RIGHT 4 TIMES
	RRCA
	RRCA
	RRCA
	CALL	GHEX		; CONVERT HIGH ORDER 4 BITS TO ASCII
	LD	(HL),A		; STORE INTO TABLE
	INC	HL		; NEXT TABLE LOCATION
	POP	AF		; RESTORE REGISTERS
	CALL	GHEX		
	LD	(HL),A		
	RET

;
; 	HEX INTO ASCII ROUTINE
;

GHEX:	AND	0FH		; STRIP HIGH 4 BITS
	CP	10		; NUMERIC?
	JR	NC,G10		; YES, SKIP FOR ALPHA
	ADD	A,'0'		; ADD 30
	RET
G10:	ADD	A,'A'-10	; ADD 40
	RET

; END OF 802HSUBS.MAC
