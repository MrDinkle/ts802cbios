	.Z80

; 	VERSION	1.00	(PRE-RELEASE)
;	DATE 5/20/81
;	MODIFIED READ/WRITE SECTOR AND READ I.D. WAIT LOOP WITH TIME OUT

;       *************************************************
;	SECTOR DEBLOCKING FOR TELEVEDIO SYSTEM 1 CP/M 2.2
;       *************************************************

;	      HOME DISK ENTRY ROUTINE
;	THIS ROUTINE IS USED TO RECALIBRATE 
;	THE CURRENT SELECTED DISK TO TRACK #0

HOME:
	LD	A,(HSTWRT)	; CHECK WRITE PENDING DATA IN BUFFER
	OR	A
	JR	NZ,HOMED	; IF WRITE DATA PENDING THEN SKIP
	LD	(HSTACT),A
HOMED:
	LD	BC,0
	CALL	SETTRK
	RET

;	             DISK SELECT ENTRY ROUTINE
;	ACCEPTS: C = DRIVE SELECT (WITH C=0 FOR SELECT DRIVE"A")
;	RETURNS: HL = DPB POINTER OF DRIVE SELECT (IF C=VALID DRIVE NUMBER)
;		 HL = 0H IF (C=INVALID DRIVE NUMBER)
;	SETS:    CP/M SECTORS PER TRACK
;		 NUMBER OF SECTORS PER BLOCK	

SELDSK:
	LD	A,C		; GET CURRENT DRIVE
	LD	(SEKDSK),A
	CP	MAXDRV+1	; CHECK WITH MAXIMUM DRIVES
	JR	C,SELDR1
	LD	HL,0		; ERROR FOR ILLEGAL DRIVE
	RET
SELDR1:
	LD	B,0
	LD	HL,DISKTAB	; DISK PARAMETER BLOCK OFFSET
	ADD	HL,BC
	LD	A,(HL)
	RLCA
	RLCA
	RLCA
	RLCA
	LD	C,A
	LD	HL,DPHDR0	; DISK PARAMETER BLOCK BASE ADDRESS
	ADD	HL,BC
	PUSH	HL		; SAVE DPB ADDRESS
	LD	DE,DPBOFF
	ADD	HL,DE
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	A,(HL)
	LD	(SPTCPM),A	; CP/M SECTOR PER TRACK
	LD	DE,HDBOFF
	ADD	HL,DE
	LD	A,(HL)
	INC	A
	LD	(SECBLK),A	; # OF SECTORS PER BLOCK
	POP	HL
	RET
;
;	SETTRK -- SET READ/WRITE TRACK
;	ACCEPTS: C = TRACK NUMBER
;

SETTRK:
	LD	(SEKTRK),BC
	RET

;
;	SETSEC -- SET READ/WRITE SECTOR
;	ACCEPTS: C = SECTOR NUMBER
;

SETSEC:
	LD	A,C
	LD	(SEKSEC),A
	RET
;
;	SETDMA -- SET READ/WRITE DMA BUFFER ADDRESS
;

SETDMA:
	LD	(DMAADR),BC
	RET

;
;	SECTRAN -- TRANSLATE SECTOR
;	ACCEPTS: BC = LOGICAL SECTOR
;	RETURNS; HL = PHYSICAL SECTOR
;

SECTRAN:
	LD	H,B
	LD	L,C
	RET

;
;	READ CP/M SECTOR ENTRY POINT
;	THIS ROUTINE READ THE SELECTED CP/M SECTOR
;	INTO SELECTED DMA BUFFER POINTER
;

READ:
	LD	A,(SEKDSK)	; CHECK IF SELECTED DISK EXISTS
	CP	MAXDRV+1
	LD	A,1
	RET 	NC		; IF NOT, RETURN WITH ERROR FLAG
	XOR	A	
	LD	(UNACNT),A
	LD	A,1
	LD	(READOP),A	; SET READ OPERATION
	LD	(RSFLAG),A	; MUST READ DATA
	LD	A,WRUAL
	LD	(WRTYPE),A	; TREAT AS UNALLOC
	JP	RWOPER		; PERFORM THE READ

;
;	WRITE ROUTINE ENTRY POINT
;	THIS ROUTINE WRITE THE SELECTED DMA BUUFER POINTER
;	INTO SELECTED CP/M SECTOR
;

WRITE:	
	LD	A,(SEKDSK)
	CP	MAXDRV+1
	LD	A,1
	RET	NC
	XOR	A
	LD	(READOP),A	; SET OPERATION TO WRITE
	LD	A,C		; SAVE WRITE TYPE
	LD	(WRTYPE),A
	CP	WRUAL		; WRITE UNALLOCATED?
	JR	NZ,CHKUNA	; CHECK FOR UNALLOC
;
;	WRITE TO UNALLOCATION, SET PARAMETERS
;
	LD	HL,SECBLK	; NEXT UNALLOCATION
	LD	DE,UNACNT
	LD	BC,5
	LDIR

CHKUNA:

;	CHECK FOR WRITE TO UNALLOCATED SECTOR

	LD	A,(UNACNT)	; ANY UNALLOCATED SECTOR REMAIN?
	OR	A
	JR	Z,ALLOC		; SKIP IF NOT

;	MORE UNALLOCATED SECTOR REMAIN

	DEC	A		; UNACNT = UNACNT-1
	LD	(UNACNT),A
	LD	A,(SEKDSK)	; GET SEEK DISK INTO A
	LD	HL,UNADSK
	CP	(HL)		; SEEK.DSK = UNALL.DSK?
	JR	NZ,ALLOC	; SKIP IF NOT

;	DISK ARE THE SAME

	LD	HL,(UNATRK)
	CALL	SKTRKCMP
	JR	NZ,ALLOC	; SKIP IF NOT

;	TRACKS ARE THE SAME

	LD	A,(SEKSEC)	; GET SEEK SECTOR INTO A
	LD	HL,UNASEC
	CP	(HL)		; SEEK.SEC = UNALL.SEC?
	JR	NZ,ALLOC	; SKIP IF NOT

;	MATCH, MOVE "UNASEC" TO NEXT SECTOR FOR FUTURE REF.

	INC	(HL)		; UNASEC = UNASEC+1
	LD	C,(HL)
	LD	A,(SPTCPM)
	CP	C
	JR	NZ,NOOVF	; SKIP IF NO OVERFLOW

;	OVERFLOW TO NEXT TRACK

	LD	(HL),0		; PRESET UNASEC = 1
	LD	HL,UNATRK
	INC	(HL)		; UNATRK = UNATRK+1

NOOVF:

;	MATCH FOUND, MARK AS UNNECESSARY READ

	XOR	A
	LD	(RSFLAG),A	; SET PRE-READ FLAG = NO
	JR	RWOPER		; PERFORM WRITE CP/M SECTOR

ALLOC:

;	NOT AN UNALLOCATED SECTOR, REQUIRES PRE-READ

	XOR	A
	LD	(UNACNT),A	; RESET UNALLOC. COUNTER = 0
	INC	A
	LD	(RSFLAG),A	; SET PRE-READ FLAG = YES.

;
;	COMMON CODE FOR READ AND WRITE ROUTINE
;

RWOPER:
	XOR	A
	LD	(ERFLAG),A	; RESET ERROR FLAG
	LD	A,(SEKSEC)	; CONVERT SEEEK SECTOR TO HOST SECTOR
	OR	A		; CLEAR CARRY FLAG
	RRA
	LD	(SEKHST),A	; SEKHST = ((SEKSEC-1)/2)+1

;	ACTIVE HOST SECTOR?

	LD	HL,HSTACT
	BIT	0,(HL)
	SET	0,(HL)		; ALWAY BECOMES 1
	JR	Z,FILHST	; FILL BUFFER IN ACTIVE FLAG = 0

;	HOST BUFFER ACTIVE, SAME AS SEEK BUFFER?

	LD	A,(SEKDSK)
	LD	HL,HSTDSK
	CP	(HL)		; SAME DISK?
	JR	NZ,NOMATCH	; SKIP IF NOT MATCH

;	SAME DISK, SAME TRACK?

	LD	HL,(HSTTRK)
	CALL	SKTRKCMP
	JR	NZ,NOMATCH	; SKIP IF NOT MATCH

;	SAME DISK, SAME TRACK, SAME BUFFER?

	LD	A,(SEKHST)
	LD	HL,HSTSEC
	CP	(HL)
	JR	Z,MATCH		; SKIP IF MATCH

NOMATCH:

;	PROPER DISK, BUT NOT CORRECT SECTOR

	LD	A,(HSTWRT)	; WRITE DATA PENDING IN BUFFER?
	OR	A
	JR	Z,FILHST	; SKIP IF NO WRITE PENDING
	CALL	WRITEHST	; IF YES, THEN WRITE DATA TO DISK
	LD	A,(ERFLAG)
	OR	A
	JR	Z,FILHST	; SKIP IF NO ERROR
FILHS2:
	XOR	A
	LD	(HSTACT),A	; RESET HOST ACTIVE FLAG

MEXIT:	LD	A,FDTOUT
	LD	(FDTIME),A
	LD	A,(ERFLAG)
	OR	A
	RET

FILHST:

;	MAY HAVE TO PRE-READ DATA TO HOST BUFFER

	LD	A,(SEKDSK)
	LD	(HSTDSK),A
	LD	HL,(SEKTRK)
	LD	(HSTTRK),HL
	LD	A,(SEKHST)
	LD	(HSTSEC),A
	LD	A,(RSFLAG)	; CHECK BUFFER REQUIRES PRE-READ
	OR	A
	CALL	NZ,READHST	; IF YES, THEN READ DATA FROM DISK

	LD	A,(ERFLAG)	; CHECK FOR I/O ERROR
	OR	A
	JR	NZ,FILHS2	; IF ERROR THEN SKIP

FILHS1:
	XOR	A		; INTO BUFFER
	LD	(HSTWRT),A	; RESET PENDING WRITE FLAG

MATCH:

;	COPY DATA TO OR FROM BUFFER

	LD	A,(SEKSEC)	; COMPUTE RELATIVE HOST BUFFER ADDRESS
	AND	SECMSK
	RRA
	LD	H,A
	LD	A,0
	RRA
	LD	L,A		; HL = ((SEKSEC-1)&SECMSK)*128

;	HL HAS RELATIVE HOST BUFFER ADDRESS

	LD	DE,HSTBUF
	ADD	HL,DE
	EX	DE,HL		; SAVE HOST ADDRESS INTO DE
	LD	HL,(DMAADR)	; GET/PUT CP/M DATA BUFFER POINTER
	EX	DE,HL
	LD	BC,128		; SET BC = LENGTH TO MOVE
	LD	A,(READOP)	; WHICH WAY?
	OR	A
	JR	NZ,RWMOVE	; SKIP IF READ OPERATION
;
;	WRITE OPERATION, MARK AND SWITCH DIRECTION
;
	LD	A,1
	LD	(HSTWRT),A	; SET WRITE PENDING FLAG ON
	EX	DE,HL		; SOURCE/DESTINATION POINTERS SWAP

RWMOVE:

;	BC INITIALLY 128, DE DESTINATION, HL IS SOURCE POINTER

	LDIR
;
;	DATA HAS BEEN MOVE TO/FROM HOST BUFFER
;
	LD	A,(WRTYPE)	; CHECK WRITE TYPE OPERATION
	CP	WRDIR		; DIRECTORY WRITE?
	JR	NZ,RWEXIT	; IF NOT A DIRECTORY WRITE THEN EXIT
				; WITH ERROR FLAG IN A
	LD	A,(ERFLAG)
	OR	A		; ELSE CHECK FOR ERROR
	JP	NZ,FILHS2	; IF ERROR THEN EXIT
	XOR	A
	LD	(HSTWRT),A	; RESET WRITE PENDING FLAG
	CALL	WRITEHST
RWEXIT:
	LD	A,(ERFLAG)
	OR	A
	JP	Z,MEXIT		; EXIT IF NO ERROR
	JP	FILHS2

;	16-BIT COMPARE BETWEEN (HL) AND (SEKTRK)

SKTRKCMP:
	LD	DE,(SEKTRK)
	OR	A
	SBC	HL,DE
	RET

;	IDENTIFY WHICH DRIVE WE'RE TALKING TO, FLOPPY OR HARD

LOCREL:
	LD	A,(HSTDSK)
	LD	C,A
	LD	B,0
	LD	HL,CTLTAB
	ADD	HL,BC
	LD	A,(HL)
	RET

;	PERFORM PHYSICAL READ

READHST:
	CALL	LOCREL
	DEC	A
	JP	NZ,FREAD
	JP	HREAD

;	PERFORM PHYSICAL WRITE

WRITEHST:
	CALL	LOCREL
	DEC	A
	JP	NZ,FWRITE
	JP	HWRITE

; 	HERE ARE THE SECTOR READ/WRITE FUNCTIONS. WE
; 	WANT TO READ/WRITE TO DISK USING THE PARAMETERS
; 	SECTOR, TRACK, DMA ADDRESS.

FREAD:
	LD	A,RDSCMD	; FDC READ COMMAND
	LD	HL,RDSTAB	; DMA INITIALIZATION TABLE
	JR	RDWRSEC		; CODE COMMON TO READ AND WRITE

FWRITE:
	LD	A,WTSCMD	; FDC WRITE COMMAND
	LD	HL,WTSTAB	; DMA INITIALIZATION TABLE FOR WRITE

RDWRSEC:
	LD	(COMAND),A
	LD	(DMAINITP),HL

	LD	HL,FDTIME
	LD	(HL),0		; DISABLE MOTOR
	INC	HL
	LD	A,(HL)		; CHECK FLOPPY MOTOR
	LD	(HL),1		; INDICATE FLOPPY MOTOR IS ON
	OR	A
	LD	A,(DSELCMD)	; CURRENT DISK SELECT AND CONFIGURE
	OUT	(DSELOP),A	; NOW TURN ON MOTOR
	JR	NZ,RWCM1	; JUMP IF MOTOR IS ALREADY ON

;	WAIT	541 MS FOR MOTOR TO GET SPEED

	SBC	HL,HL		; SET HL = 0
RWCM2:	DEC	HL
	LD	A,H
	OR	L
	LD	A,(HL)		; DUMMY INST.
	JR	NZ,RWCM2

RWCM1:
	LD	A,(HSTSEC)	; CHECK SELECT SECTOR > PHYSICAL SEC/TRK
	CP	FPSPT0
	JR	C,SSIDE1	; IF NOT THEN SELECT SIDE #1

;	ELSE SELECT SIDE #2 OF SELETED DISK

	LD	A,(DSELCMD)
	OR	00000110B	; DDEN, SIDE#2, MOTOR ON
	LD	(DSELCMD),A
	OUT	(DSELOP),A
	LD	A,(HSTSEC)
	SUB	FPSPT0		; SET TSEC=HSTSEC-PSPT0
SETSIDE:
	INC	A		; PHYSICAL SECTOR TRANSLATION
	LD	(TSEC),A

; CODE COMMON TO READ/WRITE SECTOR OPERATIONS

	LD	HL,(DMAINITP)	; GET DMA INITIAL PARAMETER POINTER
	CALL	PRTINI		; INITIALIZE DMA CHANNEL

	LD	A,10		; NO. OF RETRIES
	LD	(FRETRY),A	; ON DISK I/O OPERATION

RDWT10:	CALL	SEEK		; SEEK THE USER DEFINED TRACK
	JR	NZ,RDWT30	; ADJUST RETRY COUNTER
	LD	A,(HSTTRK)	; SET UP FDC 
	OUT	(FDCTRK),A	; TRACK REGISTER
	LD	A,(TSEC)	; SET UP FDC
	OUT	(FDCSEC),A	; SECTOR REGISTER
	LD	A,(COMAND)	; SET UP FDC
	OUT	(FDCCMD),A	; COMMAND REGISTER
	CALL	WAITWT		; WAIT FOR CONTROLLER NOT BUSY(WITH TIME-OUT)
	JR	NZ,RDWT30	; ERROR ON READ/WRITE
RDWT20:	LD	A,(ERFLAG)	; RETURN CODE
	RET			; DISK I/O SUCCESSFUL

; 	WE HAD AN ERROR ON READ/WRITE OPERATION

RDWT30:
	AND	80H		; DRIVE NOT READY ERROR (TIME-OUT CONDITION)
	RET	NZ		; EXIT IF ERROR.
	CALL	RESDMA		; RESET THE DMA ON ABORT
	LD	HL,FRETRY	; MORE RETRIES LEFT?
	DEC	(HL)		; BUMP DOWN COUNT
	JR	Z,RDWT33	; EXIT IF RETRY COUNT = 0
	LD	A,(HL)
	CP	7		; CHECK RETRY COUNT = 7
	JR	Z,RDWT31	; IF YES, THEN HOME THE HEAD.
	CP	4		; CHECK RETRY COUNT = 4
	JR	Z,RDWT31

RDWT32:				; IF RETRY COUNT NOT #7 OR #4 THEN SKIP
	LD	HL,(DMAINITP)	; RECALIBRATE THE READ/WRITE HEAD.
	CALL	PRTINI		; SETUP DMA CHANNEL FOR RETRY
	JR	RDWT10

RDWT31:
	LD	A,FRCCMD	; FORCE FDC TO TERMINATE.
	OUT	(FDCCMD),A
	CALL	WAIT		; WAIT FOR FDC COMPLETED
	LD	A,RESCMD
	OUT	(FDCCMD),A	; THEN FORCE FDC TO HOME THE HEAD TO TRACK #0
	CALL	WAIT		; WAIT FOR FDC COMPLETED.
	JR	RDWT32		; NOW RETRY READ/WRITE OPERATION.
	
RDWT33:
	CALL	ERRPRT		; PRINT DETAILED ERROR MESSAGE
	JR	RDWT20

SSIDE1:
	LD	A,(DSELCMD)
	RES	2,A		; SET SIDE SELECT = SIDE #1
	LD	(DSELCMD),A
	OUT	(DSELOP),A
	LD	A,(HSTSEC)	; AND (TSEC)=HSTSEC
	JR	SETSIDE

; 	THIS ROUTINE DOES THE ACTUAL SEEKING.
; 	TRACK NO. IS PASSED IN TRACK VARIABLE.

SEEK:	PUSH	HL
	IN	A,(FDCTRK)	; SAVE FDC DEVICE TRACK REG.
	LD	L,A
	LD	A,(HSTTRK)	; GET TRACK NO. BACK
	CP	L		; TEST CURRENT TRACK = SELECT TRACK
	JR	Z,SEEK0		; IF YES THEN SKIP.
	OUT	(FDCDAT),A	; OUTPUT TO DATA PORT
	LD	A,SEECMD	; THIS IS THE SEEK COMMAND
	OUT	(FDCCMD),A	; GIVE THE ORDER TO FDC

; 	NOW TEST FOR COMPLETION

	CALL	WAIT		; WAIT UNTIL NOT BUSY
	AND	SEEMSK		; AND OUT TRACK 0 BIT
	JR	Z,SEEK1		; IF NO ERROR THEN SKIP.
SEEK0:
	POP	HL
	RET

SEEK1:
	LD	HL,FDCDEL
SEEK2:
	DEC	HL
	LD	A,H
	OR	L
	JP	NZ,SEEK2
	POP	HL
	RET

; 	THIS ROUTINE LOOPS UNTIL THE FDC IS
; 	IN A NON-BUSY STATE, OR UNTIL A NOT-
; 	READY CONDITION IS DETECTED.

WAIT:	LD	A,15		; WE MUST DELAY ABOUT
WAIT10:	DEC	A		; 60 USECS. BEFORE READING 
	JR	NZ,WAIT10	; THE STATUS.

WAIT20:	IN	A,(FDCCMD)	; READ THE FDC STATUS
	LD	(ERFLAG),A	; SAVE IT FOR LATER

	BIT	FDCBSY,A	; ARE WE PROCESSING A COMMAND?
	JR	NZ,WAIT20	; YES, LOOP UNTIL NOT BUSY
	LD	(UNMSTA),A	; UNMASKED STATUS (FOR DEBUG)
	AND	ERRMSK		; MASK OFF NON-ERROR BITS
	LD	(ERFLAG),A	; SAVE STATUS FOR LATER
	RET

; 	THIS ROUTINE LOOPS UNTIL THE FDC IS
; 	IN A NON-BUSY STATE, OR UNTIL A NOT-
; 	READY CONDITION IS DETECTED.  TIME-OUT
; 	FOR DRIVE BUSY OCCURS AT APPROX.
; 	1.25 SECONDS AFTER COMMAND INITIATION.

WAITWT:	LD	A,15		; WE MUST DELAY ABOUT
WAITW1:	DEC	A		; 60 USECS. BEFORE READING 
	JR	NZ,WAITW1	; THE STATUS.

	LD	(TEMPBC),BC	; SAVE REGISTERS
	LD	(TEMPDE),DE
	LD	(TEMPHL),HL
	LD	BC,0C000H	; TIME OUT FOR 1.25 SECONDS
	LD	A,0
	LD	(JMPSW),A	; RESET THE FLAG FOR MESSAGE

WAITW2:	IN	A,(FDCCMD)	; READ THE FDC STATUS--2.75
	LD	(ERFLAG),A	; SAVE IT FOR LATER--3.25
	BIT	FDCRDY,A	; IS THE DEVICE NOT READY?--2.00
	JR	NZ,WAIT50	; YES, THIS IS AN ERROR--1.25

	PUSH	AF		; SAVE REGISTERS--2.75
	LD	A,(JMPSW)	; GET MESSAGE FLAG--3.25
	CP	0		; MESSAGE ALREADY SENT OUT?--1.75
	JR	NZ,WAIT30	; YES, SKIP--1.75
	DEC	BC		; COUNT DOWN--1.50
	LD	A,B		; --2.25
	OR	C		; TIME OUT?--1.00
	CALL	Z,SIGMSG	; YES, PRINT MESSAGE--2.50
WAIT40:	POP	AF		; RESTORE REGISTERS--2.50

	BIT	FDCBSY,A	; ARE WE PROCESSING A COMMAND?--2.00
	JR	NZ,WAITW2	; NO, RETURN ERROR CODE--3.00

	LD	(UNMSTA),A	; UNMASKED STATUS (FOR DEBUG)
	AND	ERRMSK		; MASK OFF NON-ERROR BITS
	LD	(ERFLAG),A	; SAVE STATUS FOR LATER

WAIT50:	LD	HL,(TEMPHL)	; RESTORE REGISTERS
	LD	DE,(TEMPDE)
	LD	BC,(TEMPBC)
	RET

WAIT30:	CALL	CONST		; CONSOLE STATUS
	CP	0		; AVAILABLE INPUT?
	JR	Z,WAIT40	; NO, SKIP
	CALL	CONIN		; GET CHARACTER
	CP	03H		; CONTROL-C?
	JR	NZ,WAIT40	; NO, LOOP BACK

	POP	AF		; RESTORE REGISTERS
	LD	HL,(TEMPHL)
	LD	DE,(TEMPDE)
	LD	BC,(TEMPBC)

	LD	A,FRCCMD	; FORCE TERMINATE
	OUT	(FDCCMD),A
	OUT	(FDCCMD),A
	CALL	RESDMA		; RESET DMA
	XOR	A
	LD	(LOGDRV),A	; SET DEFAULT DRIVE TO A
	JP	WBOOTE		; WARM-BOOT

; 	THIS ROUTINE PRINTS DOOR MESSAGE WHEN THERE 
; 	IS AN ACCESS TO A DRIVE WITH DOOR OPENED.

SIGMSG:	LD	A,1		; SET FLAG
	LD	(JMPSW),A
	LD	A,(HSTDSK)	; CURRENT DRIVE
	ADD	A,41H		; MAKE IT ASCII 
	LD	(VDRIVE),A	; SAVE FOR LATER
	LD	HL,RDYMSG	; PRINT DOOR MESSAGE
	CALL	PRNT
	RET

; 	THIS ROUTINE FILLS OUT THE VARIABLE VALUES FROM CURRENT
; 	STATE AND FDC STATUS CODE IN TABLE AND REPORT TO OPERATOR

ERRPRT:	LD	HL,MSG3		; MESSAGE HEADER
	CALL	PRNT
	LD	A,(COMAND)	; GET CURRENT COMMAND
	CP	80H		; READ COMMAND?
	JR	NZ,WRMSG	; NO, SKIP
	LD	HL,MSGRC	; READ MESSAGE
	JR	EEP
WRMSG:	LD	HL,MSGWC	; WRITE MESSAGE
EEP:	CALL	PRNT		; CURRENT COMMAND MESSAGE
	CALL	ERRHST		; GET DETAILED MESSAGE AND PRINT
	LD	HL,FSCODE	; GET STATUS TABLE ADDRESS
	LD	A,(ERFLAG)	; GET FDC STATUS CODE 
	CALL	FTAB		; CONVERT IT TO HEX AND FILL IN TABLE
	LD	HL,MSG5
	CALL	PRNT
	RET


; 	RESET THE DMA SIX TIMES TOTAL

RESDMA:	PUSH	BC		; DON'T DESTROY REGGIES
	LD	B,6		; COUNTER
RESD10:	LD	A,11000011B	; RESET THE DMA
	OUT	(DMA),A		; SO THAT IT DOESN'T RUN ON.
	DJNZ	RESD10		; LOOP FOR OTHER TIME
	POP	BC		; RESTORE REGISTER PAIR
	RET			; ALL DONE

; 	GENERAL PORT INITIALIZATION ROUTINE
;	ENTRY:		HL	->	PORT ADDRESS
;					BYTE COUNT
;					DATA
;					 |
;					 |

PRTINI:	LD	C,(HL)		; GET PORT ADDRESS
	INC	HL		
	LD	B,(HL)		; GET THE COUNT
	INC	HL		; POINT TO FIRST DATA BYTE
	OTIR			; BLOCK OUTPUT
	RET

; END OF 802HFLOP.MAC

