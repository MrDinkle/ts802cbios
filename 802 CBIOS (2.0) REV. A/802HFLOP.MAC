;	TITLE	'802HFLOP -- FLOPPY DISK CBIOS FOR CPM 2.2 7/6/81'
;
	.Z80
;
; 	VERSION	1.00	(PRE-RELEASE)
;	DATE 5/20/81
;	MODIFIED READ/WRITE SECTOR AND READ I.D. WAIT LOOP WITH TIME OUT.
;
;-------
;
;	BDOS CONSTANTS ON ENTRY TO WRITE
;
;-------
WRALL	EQU	0		;WRITE TO ALLOCATED
WRDIR	EQU	1		;WRITE TO DIRECTORY
WRUAL	EQU	2		;WRITE TO UNALLOCATED

; FDC EQUATES

DSELOP	EQU	18H		; DISK SELECT AND CONFIGURE PORT
FDCCMD	EQU	14H		; FDC STATUS AND COMMAND PORT
FDCTRK	EQU	15H		; FDC TRACK PORT
FDCSEC	EQU	16H		; FDC SECTOR PORT
FDCDAT	EQU	17H		; FDC DATA PORT

; DMA PORT ADDRESS

DMA	EQU	10H		; DMA PORT ADDRESS

; FDC STATUS BITS

FDCBSY	EQU	0		; FDC BUSY IS BIT 0
FDCIND	EQU	1		; FDC INDEX HOLE DETECTED
FDCTR0	EQU	2		; FDC TRACK 0 DETECTED
FDCCRC	EQU	3		; FDC CRC ERROR ENCOUNTERED
FDCSEE	EQU	4		; FDC SEEK ERROR ENCOUNTERED
FDCHLD	EQU	5		; FDC HEAD LOAD ACK.
FDCPRT	EQU	6		; FDC DISK IS WRITE PROTECTED
FDCRDY	EQU	7		; FDC DISK NOT READY BIT

; FDC STATUS BYTE MASKS

ERRMSK	EQU	11011100B	; MASK OFF INSIGNIFICANT BITS
SEEMSK	EQU	10011000B	; CHECK THE NOT READY BIT
DNRMSK	EQU	10000000B	; DRIVE NOT READY MASK

; FDC COMMAND BYTES

RESCMD	EQU	00000000B	; HOME HEAD COMMAND
SEECMD	EQU	00010000B	; SEEK TRACK COMMAND
HDSCMD	EQU	00110100B	; HEAD STEP, PREVIOUS DIRECTION
HSICMD	EQU	01010100B	; HEAD STEP IN, TOWARD HUB.
HSOCMD	EQU	01110100B	; HEAD STEP OUT, TOWARD EDGE.
RDSCMD	EQU	10000000B	; READ SECTOR
WTSCMD	EQU	10100000B	; WRITE SECTOR
RDACMD	EQU	11000000B	; READ SECTOR ADDRESS
RDTCMD	EQU	11100000B	; READ TRACK
WTTCMD	EQU	11110000B	; WRITE TRACK
FRCCMD	EQU	11010000B	; FORCE TERMINATION
;
FDCDEL	EQU	20000/6		; TIMER COUNTER FOR 20MS DELAY OF HEAD
FDCTIMEOUT EQU	0FFFFH		; TIMER-OUT COUNTER FOR R/W WAIT ROUTINE
;
; CP/M EQUATES

CPMSEC	EQU	16		; NO. OF 256-BYTE SECTORS USED BY CP/M
CPMSIZ	EQU	1600H		; CP/M SIZE IN BYTES.
CPMBUF	EQU	80H		; DEFAULT CP/M DMA ADDRESS
LOGDRV	EQU	0004H		; CURRENTLY LOGGED DRIVE
JP	EQU	0C3H		; JUMP OPCODE
;
; DISK PARAMETER BLOCKS.
; FIRST COME THE EQUATES 
; FOR DISK PARAMETER BLOCKS

BPDE	EQU	32		; BYTES/DIRECTORY ENTRY

; DRIVE 0 EQUATES

FOFF0	EQU	2		; NUMBER OF TRACK RESERVED FOR CP/M O.S.
FTPD0	EQU	40		; NUMBER OF TRACKS/DISK
FBPS0	EQU	256		; NUMBER OF BYTES/SECTOR
FNSID0	EQU	2		; NUMBER OF SIDE/DISK
FPSPT0	EQU	18		; NUMBER OF PHYSICAL SECTOR/TRACK
FSPT0	EQU	((FBPS0/128)*FPSPT0)*FNSID0	;NUMBER OF CP/M SECTOR/TRACK
FSPD0	EQU	FSPT0*FTPD0	; NUMBER OF SECTORS/DISK
FEPD0	EQU	64		; NUMBER OF DIRECTORY ENTRIES 
FBLS0	EQU	2048		; BLOCK SIZE
FBSH0	EQU	4		; BLOCK SHIFT FACTOR
FBLM0	EQU	(FBLS0/128)-1	; BLOCK MASK
FEXM0	EQU	0		; EXTENT MASK
FDSM0	EQU	((FSPD0-(FSPT0*FOFF0))/(FBLM0+1))-1	;CP/M BLOCK PER DISK
FDRM0	EQU	FEPD0-1 	; DIRECTORY ENTRIES - 1
FALL0	EQU	10000000B	; DIRECTORY BLOCK BIT MAP LOW
FALH0	EQU	0B		; DIRECTORY BLOCK BIT MAP HIGH
FCKS0	EQU	(FDRM0+1)/4	; SIZE OF DIRECTORY CHECK VECTOR

; DRIVE 1 EQUATES

FOFF1	EQU	2		; NUMBER OF TRACK RESERVED FOR CP/M O.S.
FTPD1	EQU	40		; NUMBER OF TRACKS/DISK
FBPS1	EQU	256		; NUMBER OF BYTES/SECTOR
FNSID1	EQU	2		; NUMBER OF DISK SIDE
FPSPT1	EQU	18		; NUMBER OF PHYSICAL SECTOR/TRACK
FSPT1	EQU	((FBPS1/128)*FPSPT1)*FNSID1	; NUMBER OF CP/M SECTORS/TRACK
FSPD1	EQU	FSPT1*FTPD1	; NUMBER OF SECTORS/DISK
FEPD1	EQU	64		; NUMBER OF DIRECTORY ENTRIES
FBLS1	EQU	2048		; BLOCK SIZE
FBSH1	EQU	4		; BLOCK SHIFT FACTOR
FBLM1	EQU	(FBLS1/128)-1	; BLOCK MASK
FEXM1	EQU	0		; EXTENT MASK
FDSM1	EQU	((FSPD1-(FSPT1*FOFF1))/(FBLM0+1))-1	; CP/M BLOCK PER DISK
FDRM1	EQU	FEPD1-1		; DIRECTORY ENTRIES-1
FALL1	EQU	10000000B	; DIRECTORY BLOCK BIT MAP LOW
FALH1	EQU	0B		; DIRECTORY BLOCK BIT MAP HIGH
FCKS1	EQU	(FDRM1+1)/4	; SIZE OF DIRECTORY CHECK VECTOR
;
;---------
;
;	CP/M TO SYSTEM DISK CONSTANTS
;
;---------
HSTSIZ	EQU	FBPS0		;SYSTEM DISK SECTOR SIZE
HSTSPT	EQU	FPSPT0*FNSID0	;SYSTEM DISK SECTOR PER TRACK
HSTBLK	EQU	HSTSIZ/128	;CP/M SECTORS/HOST BUFFER
FCPMSPT	EQU	HSTBLK*HSTSPT	;CP/M SECTOR PER TRACK
SECMSK	EQU	HSTBLK-1	;SECTOR MASK
;
; COME HERE FROM COLDSTART LOADER

DCOLD:
	XOR	A		; MAKE LOGGED DRIVE 0
	LD	(DRIVE),A
	LD	(HSTACT),A	; RESET DISK BUFFER ACTIVE FLAG
	LD	(HSTWRT),A	; RESET WRITE PENDING DATA IN BUFFER
	LD	A,FBLM0+1	; SET A=CP/M SECTOR BLOCKING
	LD	(SECBLK),A
	LD	A,00010010B	; SET DRIVE SELECT CONFIGURE
	LD	(DSELCMD),A	; SELECT DRIVE 0, DDEN, SIDE 1 AND MOTOR ON
	OUT	(DSELOP),A
	LD	A,RESCMD	; RESTORE HEAD TO TRACK#0
	OUT	(FDCCMD),A
;
;	GOTO CPM FOR SYSTEM 2
;	EXIT TO CPM
;
DEXIT:
	LD	HL,CPMBUF
	LD	(DMAADR),HL
	RET
;
; WE JUMP TO HERE WHENEVER THE USER WANTS
; TO RESTART THE SYSTEM, I. E., REREAD CP/M
; WITHOUT MODIFYING THE BIOS
DWARM:
	PUSH	BC		; SAVE BOOT FLAG (FOR SYSTEM 2)
;
;	FLUSH ALL WRITE PENDING DATA TO DISKS
;
	LD	HL,HSTACT	; CHECK DISK BUFFER ACTIVE
	BIT	0,(HL)
	RES	0,(HL)		; RESET BUFFER ACTIVE FLAG ANY WAY
	JR	Z,DWARM1	; IF BUFFER NOT ACTIVE THEN SKIP
	LD	HL,HSTWRT
	BIT	0,(HL)		; ELSE CHECK BUFFER WRITE PENDING
	RES	0,(HL)		; RESET BUFFER WRITE PENDING
	CALL	NZ,WRITEHST	; IF WRITE PENDING THEN WRITE IT OUT
DWARM1:
	POP	BC
	LD	A,C
	OR	A
	JR	Z,DEXIT		; SKIP IF SOMEBODY ELSE IS RESPONSIBLE.
;
DWARM2:
	LD	HL,CBOOTE-CPMSIZ	; SET CCP LOAD ADDRESS
	LD	(RDBTA1),HL
;
	LD	A,RDSCMD	; GOING TO READ
	LD	HL,RDBTAB	; DMA TABLE
	LD	(DMAINITP),HL
	LD	(COMAND),A	; STORE COMMAND FOR LATER
	XOR	A
	LD	(HSTDSK),A	; WARM BOOT FROM DRIVE 'A' ONLY.
;
; INITIALIZE THE TRANSFER PARAMETERS

	LD	A,0		; TRACK 0
	LD	(HSTTRK),A
	LD	A,2		; SECTOR 2
	LD	(HSTSEC),A
	LD	B,CPMSEC	; TOTAL NO. OF SECTORS

WBOO10:	PUSH	BC		; SAVE RUNNING TOTAL
	CALL	RDWTCM		; READ OR WRITE A SECTOR
 	LD	A,(HSTSEC)	; UPDATE SECTOR NO.
	INC	A
	CP	(FPSPT0*2)+1	; NO. OF SECTORS PER TRACK+1
	JR	C,WBOO20	; DIDN'T EXCEED THIS NUMBER
	LD	A,(HSTTRK)	; UPDATE TRACK NO.
	INC	A
	LD	(HSTTRK),A
	LD	A,1		; MODULO THE SECTOR NO.

WBOO20:	LD	(HSTSEC),A	; AND STORE IT AWAY
	LD	HL,(RDBTA1)	; SET DMA ADDRESS TO NEXT
	LD	BC,FBPS0
	ADD	HL,BC
	LD	(RDBTA1),HL
	POP	BC		; CHECK ON THE SECTOR COUNT
	DJNZ	WBOO10		; LOOP BACK UNTIL DONE.

	CALL	RESDMA		; RESET THE DMA 6 TIMES
	JR	DEXIT
;---------
;
;	SECTOR DEBLOCKING FOR TELEVEDIO SYSTEM 1 CP/M 2.2
;
;
;-------
;
;	HOME DISK ENTRY ROUTINE
;	THIS ROUTINE IS USED TO RECALIBRATE THE CURRENT SELECTED
;	DISK TO TRACK #0
;
;-------
DHOME:
	LD	A,(HSTWRT)	;CHECK WRITE PENDING DATA IN BUFFER
	OR	A
	JR	NZ,HOMED	;IF WRITE DATA PENDING THEN SKIP
;
	LD	(HSTACT),A
HOMED:
	XOR	A
	LD	(SEKTRK),A		;RESET SEEK TRACK TO ZERO
	RET
;
;-------
;
;	DISK SELECT ENTRY ROUTINE
;	ACCEPTS: C = DRIVE SELECT (WITH C=0 FOR SELECT DRIVE"A")
;	RETURNS: HL = DPB POINTER OF DRIVE SELECT (IF C=VALID DRIVE NUMBER)
;		 HL = 0H IF (C=INVALID DRIVE NUMBER)
;
;-------
DSELDSK:
	LD	HL,0		;SET HL = ERROR RETURN CODE
	LD	A,C
	LD	(SEKDSK),A	;SAVE DRIVE NUMBER INTO SEKDSK
	CP	2		;CHECK FOR VALID DRIVE # (MUST BE 0 OR 1)
	RET	NC		;IF INVALID DRIVE # THEN EXIT WITH HL = 0H
;
;	DISK NUMBER IS IN PROPER RANGE
;
	LD	L,A
	LD	H,0
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL		;MULTIPLY BY 16
	LD	DE,DPBASE	;BASE OF PARAMETER BLOCK
	ADD	HL,DE		;HL=.DPB(CURDSK)
	RET
;
;-------
;
;	SETTRK -- SET READ/WRITE TRACK
;	ACCEPTS: C = TRACK NUMBER
;
;-------
DSETTRK:
	LD	A,C
	LD	(SEKTRK),A
	RET
;
;-------
;
;	SETSEC -- SET READ/WRITE SECTOR
;	ACCEPTS: C = SECTOR NUMBER
;
;-------
DSETSEC:
	LD	A,C
	LD	(SEKSEC),A
	RET
;
;-------
;
;	SETDMA -- SET READ/WRITE DMA BUFFER ADDRESS
;
;-------
DSETDMA:
	LD	(DMAADR),BC
	RET
;
;-------
;
;	SECTRAN -- TRANSLATE SECTOR
;	ACCEPTS: BC = LOGICAL SECTOR
;	RETURNS; HL = PHYSICAL SECTOR
;
;-------
DSECTRAN:
	LD	H,B
	LD	L,C
	INC	HL
	RET
;
;-------
;
;	READ CP/M SECTOR ENTRY POINT
;	THIS ROUTINE READ THE SELECTED CP/M SECTOR
;	INTO SELECTED DMA BUFFER POINTER
;
;-------
DREAD:
	XOR	A	
	LD	(UNACNT),A
	LD	A,1
	LD	(READOP),A		;SET READ OPERATION
	LD	(RSFLAG),A		;MUST READ DATA
	LD	A,WRUAL
	LD	(WRTYPE),A		;TREAT AS UNALLOC
	JP	RWOPER			;PERFORM THE READ
;
;-------
;
;	WRITE ROUTINE ENTRY POINT
;	THIS ROUTINE WRITE THE SELECTED DMA BUUFER POINTER
;	INTO SELECTED CP/M SECTOR
;
;-------
DWRITE:	
	XOR	A
	LD	(READOP),A		;SET OPERATION TO WRITE
	LD	A,C			;SAVE WRITE TYPE
	LD	(WRTYPE),A
	CP	WRUAL			;WRITE UNALLOCATED?
	JR	NZ,CHKUNA		;CHECK FOR UNALLOC
;
;	WRITE TO UNALLOCATION, SET PARAMETERS.
;
	LD	HL,SECBLK		;NEXT UNALLOCATION
	LD	DE,UNACNT
	LD	BC,4
	LDIR
;
CHKUNA:
;	CHECK FOR WRITE TO UNALLOCATED SECTOR
;
	LD	A,(UNACNT)		;ANY UNALLOCATED SECTOR REMAIN?
	OR	A
	JR	Z,ALLOC			;SKIP IF NOT
;
;	MORE UNALLOCATED SECTOR REMAIN
;
	DEC	A			;UNACNT = UNACNT-1
	LD	(UNACNT),A
	LD	A,(SEKDSK)		;GET SEEK DISK INTO A
	LD	HL,UNADSK
	CP	(HL)			;SEEK.DSK = UNALL.DSK?
	JR	NZ,ALLOC		;SKIP IF NOT
;
;	DISK ARE THE SAME
;
	LD	A,(SEKTRK)		;GET SEEK TRACK INTO A
	LD	HL,UNATRK
	CP	(HL)			;SEEK.TRK = UNALL.TRK?
	JR	NZ,ALLOC		;SKIP IF NOT
;
;	TRACKS ARE THE SAME
;
	LD	A,(SEKSEC)		;GET SEEK SECTOR INTO A
	LD	HL,UNASEC
	CP	(HL)			;SEEK.SEC = UNALL.SEC?
	JR	NZ,ALLOC		;SKIP IF NOT
;
;	MATCH, MOVE "UNASEC" TO NEXT SECTOR FOR FUTURE REF.
;
	INC	(HL)			;UNASEC = UNASEC+1
	LD	A,(HL)
	CP	FCPMSPT+1		;CHECK END OF SECTOR IN CUR.TRACK?
	JR	C,NOOVF			;SKIP IF NO OVERFLOW
;
;	OVERFLOW TO NEXT TRACK
;
	LD	(HL),1			;PRESET UNASEC = 1
	DEC	HL
	INC	(HL)			;UNATRK = UNATRK+1
;
NOOVF:
;	MATCH FOUND, MARK AS UNNECESSARY READ
;
	XOR	A
	LD	(RSFLAG),A		;SET PRE-READ FLAG = NO
	JR	RWOPER			;PERFORM WRITE CP/M SECTOR
;
ALLOC:
;	NOT AN UNALLOCATED SECTOR, REQUIRES PRE-READ
;
	XOR	A
	LD	(UNACNT),A		;RESET UNALLOC. COUNTER = 0
	INC	A
	LD	(RSFLAG),A		;SET PRE-READ FLAG = YES.
;
;-------
;
;	COMMON CODE FOR READ AND WRITE ROUTINE
;
;-------
RWOPER:
	XOR	A
	LD	(ERFLAG),A		;RESET ERROR FLAG
	LD	A,(SEKSEC)		;CONVERT SEEEK SECTOR TO HOST SECTOR
	DEC	A
	OR	A			;CLEAR CARRY FLAG
	RRA
	INC	A
	LD	(SEKHST),A		;SEKHST = ((SEKSEC-1)/2)+1
;
;	ACTIVE HOST SECTOR?
;
	LD	HL,HSTACT
	BIT	0,(HL)
	SET	0,(HL)			;ALWAY BECOMES 1
	JR	Z,FILHST		;FILL BUFFER IN ACTIVE FLAG = 0
;
;	HOST BUFFER ACTIVE, SAME AS SEEK BUFFER?
;
	LD	A,(SEKDSK)
	LD	HL,HSTDSK
	CP	(HL)			;SAME DISK?
	JR	NZ,NOMATCH		;SKIP IF NOT MATCH
;
;	SAME DISK, SAME TRACK?
;
	LD	A,(SEKTRK)
	LD	HL,HSTTRK
	CP	(HL)			;SAME TRACK?
	JR	NZ,NOMATCH		;SKIP IF NOT MATCH
;
;	SAME DISK, SAME TRACK, SAME BUFFER?
;
	LD	A,(SEKHST)
	LD	HL,HSTSEC
	CP	(HL)
	JR	Z,MATCH			;SKIP IF MATCH
;
NOMATCH:
;	PROPER DISK, BUT NOT CORRECT SECTOR
;
	LD	A,(HSTWRT)		;WRITE DATA PENDING IN BUFFER?
	OR	A
	JR	Z,FILHST		;SKIP IF NO WRITE PENDING
	CALL	WRITEHST		;IF YES, THEN WRITE DATA TO DISK
	LD	A,(ERFLAG)
	OR	A
	JR	Z,FILHST		;SKIP IF NO ERROR.
FILHS2:
	XOR	A
	LD	(HSTACT),A		;RESET HOST ACTIVE FLAG.
;	**** INSERT ERROR DISPLAY MESSAGE HERE *****
;
	LD	A,(ERFLAG)
	RET
;
FILHST:
;	MAY HAVE TO PRE-READ DATA TO HOST BUFFER
;
	LD	A,(SEKDSK)
	LD	(HSTDSK),A
	LD	A,(SEKTRK)
	LD	(HSTTRK),A
	LD	A,(SEKHST)
	LD	(HSTSEC),A
	LD	A,(RSFLAG)		;CHECK BUFFER REQUIRES PRE-READ
	OR	A
	CALL	NZ,READHST		;IF YES, THEN READ DATA FROM DISK
;
	LD	A,(ERFLAG)		;CHECK FOR I/O ERROR
	OR	A
	JR	NZ,FILHS2		;IF ERROR THEN SKIP
;
FILHS1:
	XOR	A			;INTO BUFFER.
	LD	(HSTWRT),A		;RESET PENDING WRITE FLAG
;
MATCH:
;	COPY DATA TO OR FROM BUFFER
;
	LD	A,(SEKSEC)		;COMPUTE RELATIVE HOST BUFFER ADDRESS
	DEC	A
	AND	SECMSK
	RRA
	LD	H,A
	LD	A,0
	RRA
	LD	L,A			;HL = ((SEKSEC-1)&SECMSK)*128
;
;	HL HAS RELATIVE HOST BUFFER ADDRESS
;
	LD	DE,HSTBUF
	ADD	HL,DE
	EX	DE,HL			;SAVE HOST ADDRESS INTO DE
	LD	HL,(DMAADR)		;GET/PUT CP/M DATA BUFFER POINTER
	EX	DE,HL
	LD	BC,128			;SET BC = LENGTH TO MOVE
	LD	A,(READOP)		;WHICH WAY?
	OR	A
	JR	NZ,RWMOVE		;SKIP IF READ OPERATION
;
;	WRITE OPERATION, MARK AND SWITCH DIRECTION
;
	LD	A,1
	LD	(HSTWRT),A		;SET WRITE PENDING FLAG ON
	EX	DE,HL			;SOURCE/DESTINATION POINTERS SWAP
;
RWMOVE:
;	BC INITIALLY 128, DE DESTINATION, HL IS SOURCE POINTER
;
	LDIR
;
;	DATA HAS BEEN MOVE TO/FROM HOST BUFFER
;
	LD	A,(WRTYPE)		;CHECK WRITE TYPE OPERATION
	CP	WRDIR			;DIRECTORY WRITE?
	JR	NZ,RWEXIT		;IF NOT A DIRECTORY WRITE THEN EXIT
					;WITH ERROR FLAG IN A.
	LD	A,(ERFLAG)
	OR	A			;ELSE CHECK FOR ERROR
	JP	NZ,FILHS2		;IF ERROR THEN EXIT
	XOR	A
	LD	(HSTWRT),A		;RESET WRITE PENDING FLAG
	CALL	WRITEHST
RWEXIT:
	LD	A,(ERFLAG)
;
	OR	A
	RET	Z			;EXIT IF NO ERROR
	JP	FILHS2
;
;-------
; HERE ARE THE SECTOR READ/WRITE FUNCTIONS. WE
; WANT TO READ/WRITE TO DISK USING THE PARAMETERS
; SECTOR, TRACK, DMA ADDRESS.
READHST:
	LD	A,RDSCMD	; FDC READ COMMAND
	LD	HL,RDSTAB	; DMA INITIALIZATION TABLE
	JR	RDWRSEC		; CODE COMMON TO READ AND WRITE

WRITEHST:
	LD	A,WTSCMD	; FDC WRITE COMMAND
	LD	HL,WTSTAB	; DMA INITIALIZATION TABLE FOR WRITE

RDWRSEC:
	LD	(COMAND),A
	LD	(DMAINITP),HL
RDWTCM:
	LD	A,(MOTFLG)	; MOTOR ON/OFF FLAG
	CP	0		; WAS MOTOR OFF?
	JR	NZ,RWCM1	; NO, SKIP
	LD	A,(DSELCMD)	; CURRENT DISK SELECT AND CONFIGURE
	OUT	(DSELOP),A	; SEND OUT TO PORT
	LD	A,1		; MOTOR IS ON NOW
	LD	(MOTFLG),A	; SET FLAG ON
	LD	BC,40000	; NEED TO DELAY FOR 300MS
RWCM2:
	DEC	BC		; COUNT DOWN
	LD	A,B
	OR	C		; REACHED ZERO YET?
	JR	NZ,RWCM2	; NO, KEEP ON LOOPING
RWCM1:
	LD	A,(HSTDSK)	; CHECK SELECT DISK = CURRENT DISK
	LD	HL,DRIVE
	CP	(HL)
	CALL	NZ,SWITCHD	; IF NOT SAME THEN SWITCH DRIVE
	LD	A,(HSTSEC)	; CHECK SELECT SECTOR > PHYSICAL SEC/TRK
	CP	FPSPT0+1
	JR	C,SSIDE1	; IF NOT THEN SELECT SIDE #1
;
;	ELSE SELECT SIDE #2 OF SELETED DISK
;
	LD	A,(DSELCMD)
	OR	00000110B	; DDEN, SIDE#2, MOTOR ON
	LD	(DSELCMD),A
	OUT	(DSELOP),A
	LD	A,(HSTSEC)
	SUB	FPSPT0		; SET TSEC=HSTSEC-PSPT0
SETSIDE:
	LD	(TSEC),A

; CODE COMMON TO READ/WRITE SECTOR OPERATIONS

	LD	HL,(DMAINITP)	; GET DMA INITIAL PARAMETER POINTER
	CALL	PRTINI		; INITIALIZE DMA CHANNEL
RDWT1:
	LD	A,10		; NO. OF RETRIES
	LD	(FRETRY),A	; ON DISK I/O OPERATION

RDWT10:	CALL	SEEK		; SEEK THE USER DEFINED TRACK
	JR	NZ,RDWT30	; ADJUST RETRY COUNTER
	LD	A,(HSTTRK)	; SET UP FDC 
	OUT	(FDCTRK),A	; TRACK REGISTER
	LD	A,(TSEC)	; SET UP FDC
	OUT	(FDCSEC),A	; SECTOR REGISTER
	LD	A,(COMAND)	; SET UP FDC
	OUT	(FDCCMD),A	; COMMAND REGISTER
	CALL	WAITWT		; WAIT FOR CONTROLLER NOT BUSY(WITH TIME-OUT)
	JR	NZ,RDWT30	; ERROR ON READ/WRITE
RDWT20:	LD	A,(ERFLAG)	; RETURN CODE
	RET			; DISK I/O SUCCESSFUL

; WE HAD AN ERROR ON READ/WRITE OPERATION

RDWT30:
	AND	80H		; DRIVE NOT READY ERROR (TIME-OUT CONDITION)
	RET	NZ		; EXIT IF ERROR.
	CALL	RESDMA		; RESET THE DMA ON ABORT
	LD	HL,FRETRY	; MORE RETRIES LEFT?
	DEC	(HL)		; BUMP DOWN COUNT
	JR	Z,RDWT33	; EXIT IF RETRY COUNT = 0
	LD	A,(HL)
	CP	7		; CHECK RETRY COUNT = 7
	JR	Z,RDWT31	; IF YES, THEN HOME THE HEAD.
	CP	4		; CHECK RETRY COUNT = 4
	JR	Z,RDWT31
;
RDWT32:				; IF RETRY COUNT NOT #7 OR #4 THEN SKIP
	LD	HL,(DMAINITP)	; RECALIBRATE THE READ/WRITE HEAD.
	CALL	PRTINI		; SETUP DMA CHANNEL FOR RETRY
	JR	RDWT10
;
RDWT31:
	LD	A,FRCCMD	; FORCE FDC TO TERMINATE.
	OUT	(FDCCMD),A
	CALL	WAIT		; WAIT FOR FDC COMPLETED
	LD	A,RESCMD
	OUT	(FDCCMD),A	; THEN FORCE FDC TO HOME THE HEAD TO TRACK #0
	CALL	WAIT		; WAIT FOR FDC COMPLETED.
	JR	RDWT32		; NOW RETRY READ/WRITE OPERATION.
;	
RDWT33:
	CALL	ERRPRT		; PRINT DETAILED ERROR MESSAGE
	JR	RDWT20

SSIDE1:
	LD	A,(DSELCMD)
	RES	2,A		; SET SIDE SELECT = SIDE #1
	LD	(DSELCMD),A
	OUT	(DSELOP),A
	LD	A,(HSTSEC)	; AND (TSEC)=HSTSEC
	JR	SETSIDE

SWITCHD:
	LD	(HL),A		; CURRENT SELECT DISK = HSTDSK
	LD	B,A		; CONVERT SELECT DISK TO HARDWARE SWITCH
	INC	B		; B = 1 ==> A = 0001 0000B
	LD	A,00001000B	; B = 2 ==> A = 0010 0000B
SW1:				; B = 3 ==> A = 0100 0000B
	RLCA			; B = 4 ==> A = 1000 0000B
	DJNZ	SW1
;
	LD	B,A
	LD	A,(DSELCMD)	;GET DRIVE SELECT COMMAND
	AND	0FH		;STRIP OFF CURRENT DRIVE SELECTED BIT
	OR	B		;MERGER WITH NEW DRIVE SELECT BIT
	LD	(DSELCMD),A
	OUT	(DSELOP),A	;SET HARDWARE TO SELECT NEW DRIVE
;
;	UP DATE TRACK-REG BYTE READ SECTOR ID HEADER
;
;
READID:
	LD	A,10		;SET RETRY COUNT = 10
	LD	(FRETRY),A
RDID2:
	CALL	RESDMA		;RESET DMA CHANNEL
	LD	HL,RIDTAB	;SET HL = READ ID INITIALIZE TABLE POINTER
	CALL	PRTINI		;SET DMA TO TRANSFER SECTOR ID HEADER
	LD	A,RDACMD	;SET A = FDC READ ID COMMAND
	OUT	(FDCCMD),A
	CALL	WAITWT		;WAIT FOR FDC TO COMPLETE THE OPERATION
	LD	A,(ERFLAG)	;CHECK ERROR STATUS
	AND	10011100B
	JR	NZ,RDID1	;IF ERROR THEN TRY AGAIN
	LD	A,(SIDHEAD)	;GET TRACK ADDRESS TO A
	OUT	(FDCTRK),A	;UPDATE TRACK-REG IN FDC
	RET
;
RDID1:
	AND	80H		;TEST FOR DRIVE NOT READY ERROR.
	JR	NZ,RDID3	;JIF YES
	LD	HL,FRETRY	;MORE RETRY LEFT?
	LD	A,(HL)
	DEC	(HL)		;BUMP DOWN COUNT
	OR	A
	JR	NZ,RDID2	;TRY AGAIN IF COUNT NOT ZERO
	LD	A,(ERFLAG)	;ELSE RETURN WITH ERROR IN A
	OR	A
	RET
;
;
RDID3:
	LD	A,FRCCMD	; FORCE FDC TO TERMINATE.
	OUT	(FDCCMD),A
	CALL	WAIT		; WAIT FOR FDC COMPLETED
	LD	A,RESCMD
	OUT	(FDCCMD),A	; THEN FORCE FDC TO HOME THE HEAD TO TRACK #0
	JP	WAIT		; WAIT FOR FDC COMPLETED.
	
; THIS ROUTINE DOES THE ACTUAL SEEKING.
; TRACK NO. IS PASSED IN TRACK VARIABLE.

SEEK:	PUSH	HL
	IN	A,(FDCTRK)	; SAVE FDC DEVICE TRACK REG.
	LD	L,A
	LD	A,(HSTTRK)	; GET TRACK NO. BACK
	CP	L		; TEST CURRENT TRACK = SELECT TRACK
	JR	Z,SEEK0		; IF YES THEN SKIP.
	OUT	(FDCDAT),A	; OUTPUT TO DATA PORT
	LD	A,SEECMD	; THIS IS THE SEEK COMMAND
	OUT	(FDCCMD),A	; GIVE THE ORDER TO FDC

; NOW TEST FOR COMPLETION

	CALL	WAIT		; WAIT UNTIL NOT BUSY
	AND	SEEMSK		; AND OUT TRACK 0 BIT
	JR	Z,SEEK1		; IF NO ERROR THEN SKIP.
SEEK0:
	POP	HL
	RET
;
SEEK1:
	LD	HL,FDCDEL
SEEK2:
	DEC	HL
	LD	A,H
	OR	L
	JP	NZ,SEEK2
	POP	HL
	RET

; THIS ROUTINE LOOPS UNTIL THE FDC IS
; IN A NON-BUSY STATE, OR UNTIL A NOT-
; READY CONDITION IS DETECTED.

WAIT:	LD	A,15		; WE MUST DELAY ABOUT
WAIT10:	DEC	A		; 60 USECS. BEFORE READING 
	JR	NZ,WAIT10	; THE STATUS.

WAIT20:	IN	A,(FDCCMD)	; READ THE FDC STATUS
	LD	(ERFLAG),A	; SAVE IT FOR LATER
;
	BIT	FDCBSY,A	; ARE WE PROCESSING A COMMAND?
	JR	NZ,WAIT20	; YES, LOOP UNTIL NOT BUSY
	LD	(UNMSTA),A	; UNMASKED STATUS (FOR DEBUG)
	AND	ERRMSK		; MASK OFF NON-ERROR BITS
	LD	(ERFLAG),A	; SAVE STATUS FOR LATER
	RET
;
; THIS ROUTINE LOOPS UNTIL THE FDC IS
; IN A NON-BUSY STATE, OR UNTIL A NOT-
; READY CONDITION IS DETECTED.  TIME-OUT
; FOR DRIVE BUSY OCCURS AT APPROX.
; 1.25 SECONDS AFTER COMMAND
; INITIATION.

WAITWT:	LD	A,15		; WE MUST DELAY ABOUT
WAITW1:	DEC	A		; 60 USECS. BEFORE READING 
	JR	NZ,WAITW1	; THE STATUS.

	LD	(TEMPBC),BC	; SAVE REGISTERS
	LD	(TEMPDE),DE
	LD	(TEMPHL),HL
	LD	BC,0C000H	; TIME OUT FOR 1.25 SECONDS
	LD	A,0
	LD	(JMPSW),A	; RESET THE FLAG FOR MESSAGE

WAITW2:	IN	A,(FDCCMD)	; READ THE FDC STATUS--2.75
	LD	(ERFLAG),A	; SAVE IT FOR LATER--3.25
	BIT	FDCRDY,A	; IS THE DEVICE NOT READY?--2.00
	JR	NZ,WAIT50	; YES, THIS IS AN ERROR--1.25

	PUSH	AF		; SAVE REGISTERS--2.75
	LD	A,(JMPSW)	; GET MESSAGE FLAG--3.25
	CP	0		; MESSAGE ALREADY SENT OUT?--1.75
	JR	NZ,WAIT30	; YES, SKIP--1.75
	DEC	BC		; COUNT DOWN--1.50
	LD	A,B		; --2.25
	OR	C		; TIME OUT?--1.00
	CALL	Z,SIGMSG	; YES, PRINT MESSAGE--2.50
WAIT40:	POP	AF		; RESTORE REGISTERS--2.50

	BIT	FDCBSY,A	; ARE WE PROCESSING A COMMAND?--2.00
	JR	NZ,WAITW2	; NO, RETURN ERROR CODE--3.00

	LD	(UNMSTA),A	; UNMASKED STATUS (FOR DEBUG)
	AND	ERRMSK		; MASK OFF NON-ERROR BITS
	LD	(ERFLAG),A	; SAVE STATUS FOR LATER

WAIT50:	LD	HL,(TEMPHL)	; RESTORE REGISTERS
	LD	DE,(TEMPDE)
	LD	BC,(TEMPBC)
	RET

WAIT30:	CALL	CONST		; CONSOLE STATUS
	CP	0		; AVAILABLE INPUT?
	JR	Z,WAIT40	; NO, SKIP
	CALL	CONIN		; GET CHARACTER
	CP	03H		; CONTROL-C?
	JR	NZ,WAIT40	; NO, LOOP BACK

	POP	AF		; RESTORE REGISTERS
	LD	HL,(TEMPHL)
	LD	DE,(TEMPDE)
	LD	BC,(TEMPBC)

	LD	A,FRCCMD	; FORCE TERMINATE
	OUT	(FDCCMD),A
	OUT	(FDCCMD),A
	CALL	RESDMA		; RESET DMA
	LD	A,0
	LD	(LOGDRV),A	; SET DEFAULT DRIVE TO A
	JP	WBOOTE		; WARM-BOOT

; THIS ROUTINE PRINTS DOOR MESSAGE WHEN THERE IS AN ACCESS TO
; A DRIVE WITH DOOR OPENED

SIGMSG:	LD	A,1		; SET FLAG
	LD	(JMPSW),A
	LD	A,(WBFLAG)	; BOOT FLAG
	CP	1		; BOOT FROM FLOPPY
	LD	A,(HSTDSK)	; CURRENT DRIVE
	JR	Z,SIGM10	; YES, SKIP
	ADD	A,44H		; MAKE IT ASCII FOR "D"
	JR	SIGM20
SIGM10:	ADD	A,41H		; MAKE IT ASCII FOR "A"
SIGM20:	LD	(VDRIVE),A	; SAVE FOR LATER
	LD	HL,RDYMSG	; PRINT DOOR MESSAGE
	CALL	PRTMSG
	RET

; PRINT THE STRING POINTED TO BY HL
; AND TERMINATED BY NULL (0).

PRTMSG:	LD	A,(HL)
	OR	A
	RET	Z		; ALL DONE

	LD	C,A
	CALL	TTYBOUT		; OUTPUT IT
	INC	HL
	JR	PRTMSG		; AND LOOP BACK

; THIS ROUTINE FILLS OUT THE DETAILED ERROR MESSAGE TABLE
; OBTAINING VARIABLE VALUES FROM CURRENT STATE.
; THEN CALLS PRTMSG ROUTINE WITH THE TABLE ADDRESS IN HL

ERRPRT:	LD	A,(COMAND)	; CURRENT COMMAND
	CP	80H		; READ?
	JR	NZ,WRMSG	; NO, SKIP
	LD	HL,RMSG		; READ MESSAGE
	JR	ERR10
WRMSG:	LD	HL,WMSG		; WRITE MESSAGE
ERR10:	LD	DE,VCMD		; COMMAND MESSAGE ADDRESS IN TABLE
	LD	BC,5
	LDIR			; STORE IN TABLE
	LD	HL,VSIDE	; SIDE VARIABLE
	LD	A,(DSELCMD)	; MEMORY IMAGE
	BIT	2,A		; SIDE BIT
	JR	Z,ONE		; 0 - SIDE 1
	LD	(HL),32H	; ASCII	2
	JR	CONT10
ONE:	LD	(HL),31H	; ASCII 1
CONT10:	LD	HL,VTRK		; TRACK VARIABLE
	LD	A,(HSTTRK)	; CURRENT TRACK NUMBER
	CALL	FTAB		; FILL OUT TABLE ROUTINE
	LD	HL,VSEC		; SECTOR VARIABLE
	LD	A,(TSEC)	; CURRENT TARGET SECTOR
	CALL	FTAB
	LD	HL,VSTAT	; ERROR STATUS
	LD	A,(ERFLAG)	; GET ERROR FLAG
	CALL	FTAB
	LD	HL,ERRMSG	; ERROR MESSAGE TABLE ADDRESS
	CALL	PRTMSG
	RET

; THIS ROUTINE CONVERTS HEX CODE INTO ASCII AND FILL OUT THE TABLE

FTAB:	PUSH	AF		; SAVE REGISTERS
	RRCA			; ROTATE RIGHT 4 TIMES
	RRCA
	RRCA
	RRCA
	CALL	GHEX		; CONVERT HIGH ORDER 4 BITS TO ASCII
	LD	(HL),A		; STORE INTO TABLE
	INC	HL		; NEXT TABLE LOCATION
	POP	AF		; RESTORE REGISTERS
	CALL	GHEX		
	LD	(HL),A		
	RET

; HEX INTO ASCII ROUTINE

GHEX:	AND	0FH		; STRIP HIGH 4 BITS
	CP	10		; NUMERIC?
	JR	NC,G10		; YES, SKIP FOR ALPHA
	ADD	A,'0'		; ADD 30
	RET
G10:	ADD	A,'A'-10	; ADD 40
	RET

; DETAILED ERROR MESSAGE TABLE

ERRMSG:	DEFB	0DH
	DEFB	0AH
VCMD:	DEFS	5		; COMMAND
	DEFB	' ERROR: SIDE# '
VSIDE:	DEFS	1		; SIDE
	DEFB	', TRACK# '
VTRK:	DEFS	2		; TRACK NUMBER
	DEFB	', SECTOR# '
VSEC:	DEFS	2		; SECTOR NUMBER
	DEFB	', FDC STATUS '
VSTAT:	DEFS	2		; ERROR STATUS
	DEFB	0
RMSG:	DEFB	'READ '
WMSG:	DEFB	'WRITE'

; DOOR MESSAGE TABLE

RDYMSG:	DEFB	0DH
	DEFB	0AH
	DEFM	'Check the disk in drive "'
VDRIVE:	DEFS	1
	DEFM	'", and close the door.'
	DEFB	0DH
	DEFB	0AH
	DEFB	0

; TEMPORARY STORAGES FOR REGISTERS

TEMPBC:	DEFW	0
TEMPDE:	DEFW	0
TEMPHL:	DEFW	0

JMPSW:	DEFB	0		; FLAG FOR DOOR MESSAGE PRINT
;
;	
; RESET THE DMA SIX TIMES TOTAL

RESDMA:	PUSH	BC		; DON'T DESTROY REGGIES
	LD	B,6		; COUNTER
RESD10:	LD	A,11000011B	; RESET THE DMA
	OUT	(DMA),A		; SO THAT IT DOESN'T RUN ON.
	DJNZ	RESD10		; LOOP FOR OTHER TIME
	POP	BC		; RESTORE REGISTER PAIR
	RET			; ALL DONE

; GENERAL PORT INITIALIZATION ROUTINE
;	ENTRY:		HL	->	PORT ADDRESS
;					BYTE COUNT
;					DATA
;					 |
;					 |

PRTINI:	LD	C,(HL)		; GET PORT ADDRESS
	INC	HL		
PRTENT:	LD	B,(HL)		; GET THE COUNT
	INC	HL		; POINT TO FIRST DATA BYTE
	OTIR			; BLOCK OUTPUT
	RET


; DATA EQUATES AND STORAGE

; DMA INITIALIZATION TABLES FOR READ 
; AND WRITE OPERATIONS

RDSTAB:	DB	DMA		; PORT ADDRESS
	DB	15		; TABLE COUNT
	DB	11000011B	; RESET THE DMA
	DB	01101101B	; PORT ADDRESS FOLLOWS 
	DB	FDCDAT		; FDC DATA PORT ADDRESS
	DW	0FFH		; DISK BUFFER - 1
	DB	00111100B	; PORT A IS FIXED
	DB	00010000B	; PORT B IS MEMORY, INCREMENTS
	DB	11001101B	; PORT B MEMORY ADDRESS FOLLOWS
	DW	HSTBUF		; ADDRESS OF DISK BUFFER
	DB	10001010B	; READY ACTIVE HIGH, END OF BLOCK
	DB	11001111B	; LOAD REGISTERS
	DB	00000101B	; A -> B, TRANSFER MODE
	DB	11001111B	; LOAD REGISTERS
	DB	10000111B	; ARM THE DMA
 
WTSTAB:	DB	DMA		; PORT ADDRESS
	DB	15		; TABLE COUNT
	DB	11000011B	; RESET THE DMA
	DB	01101101B	; PORT ADDRESS FOLLOWS 
	DB	FDCDAT		; FDC DATA PORT ADDRESS
	DW	0FFH		; DISK BUFFER - 1
	DB	00111100B	; PORT A IS FIXED
	DB	00010000B	; PORT B IS MEMORY, INCREMENTS
	DB	11001101B	; PORT B MEMORY ADDRESS FOLLOWS
	DW	HSTBUF		; ADDRESS OF DISK BUFFER
	DB	10001010B	; READY ACTIVE HIGH, END OF BLOCK
	DB	11001111B	; LOAD REGISTERS
	DB	00000001B	; B -> A, TRANSFER MODE
	DB	11001111B	; LOAD REGISTERS
	DB	10000111B	; ARM THE DMA

; WARM BOOT INITIALIZATION TABLE

RDBTAB:	DB	DMA		; PORT ADDRESS
	DB	15		; TABLE COUNT
	DB	11000011B	; RESET THE DMA
	DB	01101101B	; PORT ADDRESS FOLLOWS 
	DB	FDCDAT		; FDC DATA PORT ADDRESS
	DW	0FFH		; DISK BUFFER - 1
	DB	00111100B	; PORT A IS FIXED
	DB	00010000B	; PORT B IS MEMORY, INCREMENTS
	DB	11001101B	; PORT B MEMORY ADDRESS FOLLOWS
RDBTA1:
	DW	0		; ADDRESS OF DISK BUFFER
	DB	10001010B	; READY ACTIVE HIGH, END OF BLOCK
	DB	11001111B	; LOAD REGISTERS
	DB	00000101B	; A -> B, TRANSFER MODE
	DB	11001111B	; LOAD REGISTERS
	DB	10000111B	; ARM THE DMA

; READ SECTOR ID. HEADER TABLE

RIDTAB:	DB	DMA		; PORT ADDRESS
	DB	15		; TABLE COUNT
	DB	11000011B	; RESET THE DMA
	DB	01101101B	; PORT ADDRESS FOLLOWS 
	DB	FDCDAT		; FDC DATA PORT ADDRESS
	DW	5		; SECTOR ID HEADER SIZE-1
	DB	00111100B	; PORT A IS FIXED
	DB	00010000B	; PORT B IS MEMORY, INCREMENTS
	DB	11001101B	; PORT B MEMORY ADDRESS FOLLOWS
	DW	SIDHEAD		; ADDRESS OF SECTOR ID BUFFER
	DB	10001010B	; READY ACTIVE HIGH, END OF BLOCK
	DB	11001111B	; LOAD REGISTERS
	DB	00000101B	; A -> B, TRANSFER MODE
	DB	11001111B	; LOAD REGISTERS
	DB	10000111B	; ARM THE DMA

; HERE ARE THE VERSION 2 DISK PARAMETER TABLES

DPBASE:

; DRIVE 0 DISK PARAMETER HEADER

HEAD0:	DW	0		; ADDR. OF SECTOR TRANSLATE TABLE FOR DISK 0
	DW	0		; BDOS SCRATCH WORDS
	DW	0		; THREE OF THEM
	DW	0
	DW	DIRBUF		; ADDR. OF DIRECTORY BUFFER FOR DISK 
	DW	DPRMB0		; ADDR. OF DISK PARAMETER BLOCK 0
	DW	CHKSV0		; ADDR. OF CHECK SCRATCHPAD
	DW	ALOCV0		; ADDR. OF DISK ALLOCATION SCRATCHPAD


; DRIVE 1 DISK PARAMETER HEADER

HEAD1:	DW	0		; ADDR. OF SECTOR TRANSLATE TABLE FOR DISK 1
	DW	0		; BDOS SCRATCH WORDS
	DW	0		; THREE OF THEM
	DW	0
	DW	DIRBUF		; ADDR. OF DIRECTORY BUFFER FOR DISK 
	DW	DPRMB1		; ADDR. OF DISK PARAMETER BLOCK 1
	DW	CHKSV1		; ADDR. OF CHECK SCRATCHPAD
	DW	ALOCV1		; ADDR. OF DISK ALLOCATION SCRATCHPAD


; HERE ARE THE DISK PARAMETER BLOCKS

DPRMB0:		
DPRMB1:	
	DW	FSPT0		; NO. OF SECTOR PER TRACK
	DB	FBSH0		; BLOCK SHIFT FACTOR
	DB	FBLM0		; BLOCK MASK
	DB	FEXM0		; EXTENT MASK
	DW	FDSM0		; DETERMINES TOTAL STORAGE CAPACITY
	DW	FDRM0		; DETERMINES TOTAL NO. OF DIR. ENTRIES
	DB	FALL0		; BLOCK ALLOCATION FOR DIRECTORY	
	DB	FALH0		; HIGH ORDER BYTE OF ABOVE
	DW	FCKS0		; SIZE OF DIRECTORY CHECK VECTOR
	DW	FOFF0		; NO. OF TRACKS RESERVED FOR SYSTEM


; DATA STORAGE FOR BDOS SCRATCHPAD AREAS

DIRBUF:	DS	128		; DIRECTORY BUFFER

; DRIVE 0 STORAGE AREA

ALOCV0:	DS	(FDSM0/8)+1	; ALLOCATION VECTOR STORAGE
CHKSV0:	DS	FCKS0		; CHECK VECTOR STORAGE

; DRIVE 1 STORAGE AREA

ALOCV1:	DS	(FDSM1/8)+1	; ALLOCATION VECTOR STORAGE
CHKSV1:	DS	FCKS1		; CHECK VECTOR STORAGE

; DISK I/O COMMAND PARAMETERS

DRIVE:	DS	1		; CURRENTLY SELECTED DRIVE
COMAND:	DS	1		; CURRENT COMMAND
DSELCMD:
	DS	1		; DRIVE CONFIGURE
TSEC:	DS	1		; TEMP. READ/WRITE SECTOR VARIABLE.
FRETRY:	DS	1		; RETRY COUNT
UNMSTA:	DS	1		; UNMASKED VERSION OF ABOVE
DMAINITP:
	DS	2		; DMA INITIALIZE PARAMETER POINTER
;-------
;
;	UNITIALIZED RAM DATA AREAS
;
;-------
SECBLK:	DS	1			;SECTOR BLOCKING.
SEKDSK:	DS	1			;SEEK DISK NUMBER
SEKTRK:	DS	1			;SEEK TRACK NUMBER
SEKSEC:	DS	1			;SEEK SECTOR NUMBER
;
HSTDSK: DS	1			;HOST DISK NUMBER
HSTTRK:	DS	1			;HOST TRACK NUMBER
HSTSEC:	DS	1			;HOST SECTOR NUMBER
;
SEKHST:	DS	1			;SEEK HOST SECTOR NUMBER
HSTACT:	DS	1			;HOST ACTIVE FLAG
HSTWRT:	DS	1			;HOST BUFFER WRITE PENDING FLAG
;
UNACNT:	DS	1			;UNALLOCATION SECTOR COUNT
UNADSK:	DS	1			;LAST UNALLOC DISK
UNATRK: DS	1			;LAST UNALLOC TRACK
UNASEC:	DS	1			;LAST UNALOCA SECTOR
;
ERFLAG:	DS	1			;ERROR REPORTING
RSFLAG:	DS	1			;PRE-READ SECTOR FLAG
READOP:	DS	1			;0 IF WRITE OPERATION; 1 IF READ OPER.
WRTYPE:	DS	1			;WRITE OPERATION TYPE
DMAADR:	DS	2			;LAST DMA ADDRESS
HSTBUF:	DS	HSTSIZ			;HOST DISK I/O BUFFER AREA.
;
SIDHEAD:
	DS	6			;BUFFER FOR READING SECTOR ID HEADER
;
;TEMPHL: DS	2			;WORKING STORAGE FOR R/W WAIT ROUTINES.
;
PREVDR:	DB	0
SAVDR:	DS	1
;	END
