
;	TITLE	'802HHARD -- TANDON TM-603S CBIOS FOR CPM 2.2 6/26/81'
;
;   '802HHARD' IS THE I/O DRIVER FOR CPM 2.2 USING A TANDON
;   TM-603S HARD DISK DRIVE. ALL OTHER I/O, INCLUDING FLOPPY DISK,
;   IS PERFORMED BY AN EXTERNAL ROUTINE.
;
;	MODIFIED SECTORS BLOCK/DEBLOCKING ROUTINES TO DO PRE-READ
;	THE SECTOR BEFORE WRITING, IF CURRENT BUFFER IN MEMORY IS
;	NOT MATCH WITH WRITE REQUEST SECTOR ***8/11/81*** TRAN T.N.
;
;	============
;	** MACROS **
;	============

;	MACLIB	Z80

;	---SET FLAG BIT---
;
;
SFLG$	MACRO	?BIT

	MVI	A,?BIT		;; A = BIT TO SET
	CALL	SETBIT		;; SET THE BIT

	ENDM

;	---RESET FLAG BIT---
;
;
CFLG$	MACRO	?BIT

	MVI	A,255-?BIT	;; A = CLEAR MASK
	CALL	CLRBIT		;; RESET THE BITD

	ENDM

;	---TEST A FLAG BIT---
;
;
TFLG$	MACRO	?BIT

	MVI	A,?BIT		;; A = BIT UNDER TEST
	CALL	TSTBIT		;; TEST THE BIT

	ENDM

	PAGE
;	---EQUATES---
;
;
;	STANDARD CP/M CONSTANTS
;
;CPMSIZ	EQU	1600H		;LENGTH OF CCP AND BDOS
NSECT	EQU	CPMSIZ/128	;NUMBER SECTORS TO WARM BOOT
;BUFF	EQU	80H		;DEFAULT BUFFER
;
;	HARD DISK - CP/M INTERFACE
;
MAXHD	EQU	3		;NUMBER OF LOGICAL HARD DISKS
MAXSEC	EQU	32		;NUMBER OF SECTORS PER TRACK
MAXHED	EQU	6		;NUMBER OF HEADS
MAXCYL	EQU	153		;NUMBER OF CYLINDERS (TM-603S)
MAXTPD	EQU	MAXCYL*MAXHED	;NUMBER OF TRACK PER DRIVE (TM-603S)
PCMPCYL	EQU	128		;BEGIN WRITE PRECOMP. HERE
BLKSIZ	EQU	4096		; # BYTES PER BLOCK
CPMSPT	EQU	2*MAXSEC	; # CPM SECTORS PER TRACK
;
;	LOGICAL DRIVE #0 EQUATES
;
CPM0	EQU	2		;NUMBER OF TRACK RESERVED FOR CP/M O.S.
OFF0	EQU	2		;TRACK OFFSET
TPD0	EQU	438		;NUMBER OF TRACKS
SPD0	EQU	CPMSPT*TPD0	;NUMBER OF CP/M SECTOR/DISK
EPD0	EQU	512		;NUMBER OF DIRECTORY ENTRIES
BLS0	EQU	BLKSIZ		;CP/M BLOCK SIZE
BSH0	EQU	5		;BLOCK SHIFT FACTOR
BLM0	EQU	(BLS0/128)-1	;BLOCK MASK
EXM0	EQU	1		;EXTENT MASK
;DSM0	EQU	04C3H
DSM0	EQU	((SPD0-(CPMSPT*CPM0))/(BLM0+1))-1	;MAX. DISK BLOCKS.
DRM0	EQU	EPD0-1		;DIRECTORY ENTRIES-1
ALL0	EQU	11111111B	;DIRECTORY ALLOCATION BITS MAP
ALH0	EQU	00000000B
CKS0	EQU	0		;SIZE OF DIRECTORY CHECK VECTOR
;
;	LOGICAL DRIVE #1 EQUATES
;
CPM1	EQU	0		;NUMBER OF TRACK RESERVED FOR CP/M O.S.
OFF1	EQU	TPD0		;TRACK OFFSET
TPD1	EQU	436		;NUMBER OF TRACKS
SPD1	EQU	CPMSPT*TPD1	;NUMBER OF CP/M SECTOR/DISK
EPD1	EQU	512 		;NUMBER OF DIRECTORY ENTRIES
BLS1	EQU	BLKSIZ		;CP/M BLOCK SIZE
BSH1	EQU	5		;BLOCK SHIFT FACTOR
BLM1	EQU	(BLS1/128)-1	;BLOCK MASK
EXM1	EQU	1		;EXTENT MASK
DSM1	EQU	((SPD1-(CPMSPT*CPM1))/(BLM1+1))-1	;MAX. DISK BLOCKS.
DRM1	EQU	EPD1-1		;DIRECTORY ENTRIES-1
ALL1	EQU	11111111B	;DIRECTORY ALLOCATION BITS MAP
ALH1	EQU	00000000B
CKS1	EQU	0		;SIZE OF DIRECTORY CHECK VECTOR
;
;	LOGICAL DRIVE #2 EQUATES
;
GABT	EQU	1		;UNUSED TRACK FOR FLOPPY SIMULATION
GABS	EQU	16		;UNUSED CPM SECTOR FOR FLOPPY SIMULATION
CPM2	EQU	0		;NUMBER OF TRACK RESERVED FOR CP/M O.S.
OFF2	EQU	OFF1+TPD1+GABT	;TRACK OFFSET
TPD2	EQU	MAXTPD-OFF2	;NUMBER OF TRACKS
SPD2	EQU	(CPMSPT*TPD2)-GABS		;NUMBER OF CP/M SECTOR/DISK
EPD2	EQU	64		;NUMBER OF DIRECTORY ENTRIES
BLS2	EQU	2048		;CP/M BLOCK SIZE
BSH2	EQU	4		;BLOCK SHIFT FACTOR
BLM2	EQU	(BLS2/128)-1	;BLOCK MASK
EXM2	EQU	0		;EXTENT MASK
DSM2	EQU	((SPD2-(CPMSPT*CPM2))/(BLM2+1))-1	;MAX. DISK BLOCKS.
DRM2	EQU	EPD2-1		;DIRECTORY ENTRIES-1
ALL2	EQU	10000000B	;DIRECTORY ALLOCATION BITS MAP
ALH2	EQU	00000000B
CKS2	EQU	0		;SIZE OF DIRECTORY CHECK VECTOR
;	
RPTERRS	EQU	TRUE		;REPORT ERROR STATUS TO OPERATOR
;
;   BIT FLAGS
;
F$RDOP	EQU	1		;READ OPERATION
F$RIP	EQU	2		;READ IN PROGRESS
F$WIP	EQU	4		;WRITE IN PROGRESS
F$INIT	EQU	080H		;CONTROLLER INITIALIZED
;
;   DRIVE COMMANDS
;
STEPRAT	EQU	7		;STEPPING RATE, EACH COUNT = 0.5 MS
;				; 0 = 10 US., 1 = 0.5 MS, ETC.
;
;   DRIVE STATUS
;
WREADY	EQU	040H		;DRIVE IS READY
WFAULT	EQU	020H		;WRITE FAULT ON DRIVE
WCMPLT	EQU	010H		;SEEK COMPLETE
;
;   CONTROLLER COMMANDS
;
WREST	EQU	010H+STEPRAT	;BASIC RESTORE COMMAND + STEPPING RATE
WSEEK	EQU	060H+STEPRAT	;BASIC SEEK COMMAND + STEPPING RATE
WREAD	EQU	020H		;READ SECTOR
WWRITE	EQU	030H		;WRITE SECTOR
WFMT	EQU	050H		;FORMAT
;
;   CONTROLLER STATUS
;
WBUSY	EQU	080H		;CONTROLLER BUSY
WDRQ	EQU	008H		;DATA REQUEST
WERROR	EQU	001H		;ERROR STATUS PRESENT
;
WEBLK	EQU	080H		;BAD BLOCK DETECT
WECRCD	EQU	040H		;CRC ERROR - DATA FIELD
WECRCI	EQU	020H		;CRC ERROR - ID FIELD
WENOT	EQU	010H		;ID NOT FOUND
WEABORT	EQU	004H		;ABORTED COMMAND
WETR0	EQU	002H		;TRACK 000 ERROR
WEDAM	EQU	001H		;DATA ADDRESS MARK NOT FOUND
;
;   DRIVE/CONTROLLER I/O
;
CBASE	EQU	48H		;BASE ADR OF THE CONTROLLER
;
WDATA	EQU	CBASE		;DATA PORT (I/O)
WPCYL	EQU	CBASE+1		;WRITE PRECOMP CYLINDER NUMBER (O)
WERRS	EQU	CBASE+1		;ERROR DEFINITION (I)
WCOUNT	EQU	CBASE+2		;SECTOR COUNT (I/O)
WSECT	EQU	CBASE+3		;SECTOR NUMBER (I/O)
WLOCYL	EQU	CBASE+4		;CYLINDER NUMBER, LOW ORDER BITS(I-O)
WHICYL	EQU	CBASE+5		;CYLINDER NUMBER, HIGH ORDER BITS (I/O)
WSDH	EQU	CBASE+6		;SECTOR SIZE, DRIVE SELECT, HEAD SELECT. (I/O)
WCMD	EQU	CBASE+7		;COMMAND PORT (O)
WSTAT	EQU	CBASE+7		;STATUS PORT (I)
;
;   ASCII CHARACTERS
;
CTLC	EQU	3		;CONTROL C TO ABORT
BELL	EQU	7		;DING
RETRYCNT EQU	5		;ERROR RETRY COUNT
;
;
DPBOFF	EQU	10		;OFFSET TO DPB ADDRESS IN THE HEADER
HDBOFF	EQU	3		;OFFSET TO BLOCK MASK IN DPB
;
	PAGE

;	======================
;	** DISK DEFINITIONS **
;	======================

;	---DISK PARAMETER HEADER---
;
DPHDR0:	DW	0		;TANDON DRIVE
	DW	0
	DW	0
	DW	0
	DW	DIRBFR
	DW	HDBLK0
	DW	LAST
	DW	HALL0
DPHDR1:
	DW	0
	DW	0
	DW	0
	DW	0
	DW	DIRBFR
	DW	HDBLK1
	DW	LAST
	DW	HALL1
DPHDR2:
	DW	0
	DW	0
	DW	0
	DW	0
	DW	DIRBFR
	DW	HDBLK2
	DW	LAST
	DW	HALL2
;
;	---DISK PARAMETER BLOCK---
;
;   THIS TABLE DEFINES HOW THE HARD DISK IS CONFIGURED.
;   AT PRESENT THE DISK IS SET UP AS FOLLOWS --
;
;	1. THE CPM LOGICAL BLOCK SIZE IS 4096 BYTES.
;
;	2. THE MOST WE CAN GET WITH A BLOCK SIZE OF 4096 WOULD BE 2048.
;
;	3. THE FIRST TWO TRACKS ARE RESERVED FOR THE SYSTEM. THIS WILL
;	   ALLOW AN AGGREGATE CCP/BDOS/CBIOS SIZE OF 16 K-BYTES.
;
HDBLK0:	DW	CPMSPT		;SPT: SECTORS PER TRACK
	DB	BSH0		;BSH: BLOCK SHIFT FACTOR
	DB	BLM0		;BLM: BLOCK MASK
	DB	EXM0		;EXM: NULL MASK
	DW	DSM0		;DSM: (DISK SIZE) - 1
	DW	DRM0		;DRM: (DIR SIZE) - 1
	DB	ALL0		;AL0: DIRECTORY ALLOCATION BITS, MSB
	DB	ALH0		;AL1:	* LSB
	DW	CKS0		;CKS: CHECK SIZE
	DW	OFF0		;OFF: TRACK OFFSET

HDBLK1:
	DW	CPMSPT
	DB	BSH1
	DB	BLM1
	DB	EXM1
	DW	DSM1
	DW	DRM1
				;	Note:  the directory allocation
				;	is for a full 1024 entries, even
				;	though only 512 are used at present.
	DB	ALL1
	DB	ALH1
	DW	CKS1
	DW	OFF1

HDBLK2:
	DW	CPMSPT
	DB	BSH2
	DB	BLM2
	DB	EXM2
	DW	DSM2
	DW	DRM2
	DB	ALL2
	DB	ALH2
	DW	CKS2
	DW	OFF2
;
	PAGE
;	=====================
;	** CBIOS FUNCTIONS **
;	=====================
;
;	---COLD BOOT---
;
MCOLD:	CALL	INIT		;INIT FLAGS & VARIABLES
	MVI	A,WREST		;RESTORE COMMAND
	OUT	WCMD
MCOLD1:	IN	WSTAT
	ANI	WBUSY		;WAIT TILL DONE
	JNZ	MCOLD1
	JMP	XIT		;GOTO CPM
;
;	---WARM BOOT---
;
MWARM:	MOV	A,C		;GET BOOT FLAG
	ORA	A		;WANT US TO BOOT?
	JZ	XIT		;NO, SOMEBODY ELSE IS RESPONSIBLE.
;
HWBOOT:	MVI	C,0
	CALL	MSELDSK		;SELECT DRIVE ZERO
;
	CALL	MHOME		;SEEK TO TRACK ZERO
	LXI	H,CBOOTE-CPMSIZ	;CPM LOAD ADR
	SHLD	DMADR		;  SAVE IT
	MVI	C,3
	CALL	MSETSEC		;SET SECTOR ADR
	MVI	A,NSECT 	; # SECTORS TO WARM BOOT
;
WB1:	STA	SECNT		;SAVE THE SECTOR COUNT
	CALL	MREAD		;READ A SECTOR FROM THE HARD DISK
	ORA	A
	JZ	WB2		;JIF READ OK
	LXI	H,MSG1		;  'CAN'T BOOT'
	CALL	PRNT		;PRINT ERROR MSG
	CALL	CONIN		;WAIT FOR OPER
	CALL	CRLF
	JMP	HWBOOT		;TRY ANOTHER BOOT
;
WB2:	LHLD	DMADR
	LXI	D,128
	DAD	D		;BUMP DMA ADR
	SHLD	DMADR
	LXI	H,R$SEC
	MOV	C,M
	INR	C		;INCR SECT ADR
	INR	C
	CALL	MSETSEC		;SET NEW SECT ADR
	LDA	SECNT		;A = SECTOR COUNT
	DCR	A
	JNZ	WB1		;JIF MORE TO READ
;
;	---EXIT TO CPM---
;
XIT:	LXI	H,BUFF
	SHLD	DMADR		;INIT DMA ADR
	RET
;
;	---SECTOR TRANSLATE ROUTINE---
;
MSECTRAN:
	LXI	H,0
	DAD	B		;DON'T XLATE -- USE SECT ADR AS IS
	INX	H		;     PLUS ONE
	RET
;
;	---SET DRIVE NUMBER---
;
MSELDSK:
	MOV	A,C		;GET LOGICAL DRIVE NUMBER
	CPI	MAXHD		;LEGAL DRIVE?
	JC	@S1A		;YES, GO COMPUTE DPH ADDRESS
	LXI	H,0		;ERROR - TELL BDOS
	RET
;
@S1A:	STA	LOGDSKN		;SAVE DRIVE NUMBER
;****************************************************************************
	LXI	H,R$DSK		;*** TEMPERARY ONLY SUPPORT 1 H.DISK*
	MVI	M,0		;SET HARD DISK DRIVE SELECT ALWAY = 0
;****************************************************************************
 	LXI	H,DPHDR0	;ADR OF PARM TABLE
 	RLC			;MULTIPLY DRIVE NUMBER BY 16
 	RLC
 	RLC
 	RLC
 	MOV	C,A		;OFFSET TO DPH FOR THIS DRIVE
 	MVI	B,0
 	DAD	B
	.Z80
	PUSH	HL		;SAVE REGISTERS
	LD	DE,DPBOFF
	ADD	HL,DE
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	DE,HDBOFF
	ADD	HL,DE
	LD	A,(HL)
	LD	(BLKMSK),A
	POP	HL		;RESTORE REGISTERS
	.8080
 	RET
;
;	---SET SECTOR ADR---
;
MSETSEC:
	MOV	A,C
 	DCR	A
 	STA	R$SEC		;SAVE SECTOR ADR
; SET REAL SECTOR ADR FOR THE H/D DRIVER
 	ANI	NOT 1		;CLEAR LOW ORDER BIT
 	RRC			;THERE ARE 2 CPM SECTORS PER H/D SECT
 	STA	RSA		;SAVE REAL SECTOR ADR
 	RET
;
;	---SET TRACK ADDRESS---
;
MSETTRK:
	.Z80
	LD	(R$TRK),BC	;SAVE TRACK ADR
	.8080
 	RET
;
;	---SET DMA ADDRESS---
;
MSETDMA:
	.Z80
	LD	(DMADR),BC	;SAVE DMA ADR
 	.8080
	RET
;
	PAGE
;	======================================
;	** HARD DISK BLOCK/DEBLOCK ROUTINES **
;	======================================

;	---HARD DISK READ---
;
;
MREAD:	XRA	A
	STA	ERFLG		;CLEAR THE ERROR FLAG
	SFLG$	F$RDOP		;SET READ OPERATION FLAG
	TFLG$	F$WIP		;WRITE IN PROGRESS ?
	CNZ	HWRITE		;YES, WRITE DATA BEFORE READ
	CFLG$	F$WIP		;RESET 'WIP' FLAG
	CALL	TSTHST		;HOST = REQ ?
	JNZ	HDRD1		;NO, READ A BLOCK
	TFLG$	F$RIP		;PRIOR BLOCK READ ?
	JNZ	HDRD2		;YES, JUST EXTRACT DATA FROM BFR
;
HDRD1:	CALL	SETHST		;MAKE HOST=REQ
	CALL	HREAD		;READ A BLOCK
HDRD2:	CALL	GETDMA		;GET DMA ADR, SET POINTERS
	XCHG
	.Z80
	LDIR			;MOVE DATA TO RAM
	.8080
	SFLG$	F$RIP		;SET READ-IN-PROGRESS FLAG
	LDA	ERFLG		;ERROR FLAG
	ORA	A
	RZ			;RETURN IF NO ERROR
	CFLG$	F$RIP		;ELSE CLEAR READ IN PROGRESS FLAG
	LDA	ERFLG
	RET
;
;
;	---HARD DISK WRITE---
;
MWRITE:	XRA	A
	STA	ERFLG		;CLEAR THE ERROR FLAG
	CFLG$	F$RIP		;CLEAR READ-IN-PROGRESS FLAG
	MOV	A,C		;A = WRITE MODE
	DCR	A
	JZ	WDIR		;DO DIRECTORY WRITE
	JM	WNORM		;DO NORMAL WRITE
	DCR	A
	JZ	WUN		;DO UNALLOCATED WRITE
	JMP	WNORM		;ELSE DO NORMAL WRITE
;
;   UNALLOCATED WRITE
;
WUN:	TFLG$	F$WIP		;WRITE IN PROGRESS ?
	CNZ	HWRITE		;YES, WRITE DATA IN BFR
; SET UNALLOC RECORD PARAMETERS
	.Z80
	LD	A,(BLKMSK)	;BLOCK MASK
	INC	A		;PLUS ONE
	.8080
	STA	U$CNT		;SET UNALLOC RECORD COUNT
	LHLD	R$DSK
	SHLD	U$DSK		;UPDATE DRIVE & SECTOR
	LHLD	R$TRK
	SHLD	U$TRK		;UPDATE TRACK ADR
	CALL	SETHST		;SET HOST = REQ
	CALL	BUMP		;BUMP UNALC PARMS FOR NEXT PASS
; XFER DATA TO CTLR BFR
WXFER:	CFLG$	F$RDOP		;CLEAR READ OPER FLAG
	CALL	GETDMA		;GET DMA ADR
	.Z80
	LDIR			;MOVE DATA TO CTLR BFR
	.8080
	SFLG$	F$WIP		;SET WRITE-IN-PROGRESS FLAG
	LDA	ERFLG		;ERROR FLAG
	RET
;
;   NORMAL WRITE
;
WNORM:	LDA	U$CNT		;UNALC RECORD COUNT
	ORA	A
	JZ	WALC		;JIF DO ALLOC WRITE
	LXI	H,U$TRK
	CALL	DSKCMP		;UNALC DSK/TRK = REQ DSK/TRK ?
	JNZ	WALC		;NO, DO ALLOC WRITE
	LDA	R$SEC
	CMP	M		;UNALC SECT = REQ SECT ?
	JNZ	WALC		;NO, DO ALLOC WRITE
	CALL	BUMP		;BUMP UNALC PARMS FOR NEXT PASS
	CALL	TSTHST		;HOST = REQ ?
	JZ	WN1		;YES, CON'T TO FILL THE BFR
	TFLG$	F$WIP		;WRITE IN PROGRESS ?
	CNZ	HWRITE		;YES, WRITE OLD DATA ONTO DISK
	CALL	SETHST		;MAKE HOST = REQ
;
WN1:	TFLG$	F$RDOP		;INTERVENING READ ?
	CNZ	HREAD		;YES, READ OLD UNALC DATA
	JMP	WXFER		;MOVE DATA TO BFR, EXIT
;
;   ALLOCATED WRITE
;
WALC:	XRA	A
	STA	U$CNT		;CLEAR UNALC RECORD COUNT
	CALL	TSTHST		;HOST = REQ ?
	JZ	WXFER		;YES -	MOVE DATA TO BFR, EXIT
	TFLG$	F$WIP		;WRITE IN PROGRESS ?
	CNZ	HWRITE		;YES, WRITE OLD DATA ONTO DISK
	CALL	SETHST		;MAKE HOST = REQ
	CALL	HREAD		;READ IN ALLOCATED DATA
	JMP	WXFER		;MOVE NEW DATA IN BFR, EXIT
;
;   DIRECTORY WRITE
;
WDIR:	XRA	A
	STA	U$CNT		;CLEAR UNALC RECORD COUNT
	CFLG$	F$RDOP		;RESET 'RDOP' FLAG
	TFLG$	F$WIP		;WRITE IN PROGRESS ?
	CNZ	HWRITE		;YES, WRITE OLD DATA ONTO THE DISK
	CFLG$	F$WIP		;CLEAR 'WIP' FLAG
	CALL	SETHST		;MAKE HOST = REQ
	CALL	HREAD		;READ DIR DATA
	RNZ			;RIF READ ERROR
	CALL	GETDMA		;GET DMA ADR, SET POINTERS
	.Z80
	LDIR			;MOVE DATA TO CTLR BFR
	.8080
	JMP	HWRITE		;WRITE DIR DATA, EXIT

;	---TEST HOST---
;
;   DETERMINES IF THE HOST DISK ADDRESS IS
;   THE SAME AS THE REQUESTED DISK ADDRESS.
;
;
TSTHST: LXI	H,H$TRK
	CALL	DSKCMP		;TRACK & DRIVE THE SAME ?
	RNZ			;RIF NO
	LDA	RSA
	CMP	M		;SECTOR THE SAME ?
	RET			;IF A = 0 THEN THEY MATCH

;	---SET HOST---
;
;   SETS THE HOST DISK ADDRESS TO BE THE
;   SAME AS THE REQUESTED DISK ADDRESS.
;
;
SETHST: LDA	R$DSK
	STA	H$DSK		;DRIVE #
	LHLD	R$TRK
	SHLD	H$TRK		;TRACK ADR
	LDA	RSA
	STA	H$SEC		;SECTOR ADR
	RET

;	---BUMP---
;
;   BUMPS PARAMETERS FOR UNALLOCATED WRITES.
;   PARMS ARE CHANGED FOR THE NEXT PASS THRU
;   THE CODE (NOT THE CURRENT PASS).
;
;
BUMP:	LXI	H,U$CNT 	;UNALC RECORD COUNT
	DCR	M		;  DECR IT
	DCX	H		;H/L = U$SEC
	INR	M		;  INCR IT
	MOV	A,M
	CPI	CPMSPT		;CPM SECTORS PER TRACK
	RC			;RIF STAY ON SAME TRACK
; OVERFLOW TO NEXT TRACK
	MVI	M,0		;RESET SECTOR ADR
	LHLD	U$TRK
	INX	H		;INCR TRACK ADR
	SHLD	U$TRK
	RET

;	---GET DMA ADDRESS---
;
;   SETS THE CONTROLLER BUFFER ADDRESS TO THE CORRECT
;   STARTING POINT. ALSO SETS B=128 & H/L=DMADR.
;
;
GETDMA: LXI	H,SECTOR	;LOCAL SECTOR BUFFER
	LXI	B,128		;COUNT FOR ONE SECTOR
	LDA	R$SEC		;REQUESTED SECTOR
	RRC
	JNC	GET1		;JIF USE 1ST HALF OF BFR
	DAD	B		;   USE 2ND HALF OF BFR
GET1:	XCHG			;DESTINATION TO DE (LOCAL SECTOR BUFFER)
	LHLD	DMADR		;SOURCE TO HL (PROGRAM DMA ADDRESS)
	RET

	PAGE
;	======================================
;	** HARD DISK I/O & SUPPORT ROUTINES **
;	======================================
;
;	---READ A BLOCK---
;
HREAD:
	MVI	A,WREAD		;SET A = READ COMMAND
	JMP	WRWOP		;GO TO READ/WRITE ROUTINE
;
HWRITE:
	MVI	A,WWRITE	;SET A = WRITE COMMAND
;
WRWOP:
	STA	RCM		;SAVE R/W COMMAND FOR LATER USED
	MVI	A,RETRYCNT	;SET ERROR RETRY COUNT.
	STA	ERRCNT
;
WRWOP1:
	CALL	SLCT		;SET UP FOR I/O
	LDA	RCM
	OUT	WCMD		;PERFORM R/W OP.
	MOV	E,A
	CALL	GETIO
	MOV	A,E
	CPI	WREAD		;TEST WE ARE IN READ MODE
	JNZ	WRWOP2		;* IF NOT THEN DO MEMORY TO I/O TRANSFER
	.Z80
	INIR			;* ELSE DO I/O TO MEMORY TRANSFER
	.8080
	JMP	WRWOP3
;
WRWOP2:
	.Z80
	OTIR
	.8080
;
WRWOP3:
	CALL	ERRORS		;THEN CHECK ERROR STATUS
	MVI	A,0
	RZ			;EXIT IF NO ERROR
	MVI	A,WREST
	OUT	WCMD		;DO RESTORE COMMAND
WRWOP4:
	IN	WSTAT
	ANI	WBUSY
	JNZ	WRWOP4		;WAIT UNTIL NOT BUSY.
;
	LDA	ERRCNT		;CHECK ERROR RETRY COUNT = 0
	DCR	A
	STA	ERRCNT
	JNZ	WRWOP1		;IF NOT ZERO THEN DO R/W AGAIN
	MVI	A,1		;ELSE SET ERROR FLAG
	STA	ERFLG
	RET
;
;	---SET UP FOR READ/WRITE COMMANDS---
;
GETIO:	IN	WSTAT		;WAIT FOR DRQ
	ANI	WDRQ
	JZ	GETIO
;
	LXI	H,SECTOR	;POINT TO SECTOR BUFFER
	LXI	B,WDATA		;B = 0, C = DATA PORT
	RET
;
;	---SEEK TO TRACK ZERO---
;
MHOME:	TFLG$	F$WIP
	.Z80
	JR	NZ,@S1B		;JIF WRITE IN PROGRESS
	.8080
	MVI	A,F$INIT	;* CLEAR READ/WRITE FLAGS
	STA	FLAGS		;MAKE HOST INACTIVE
@S1B:	LXI	B,0
	CALL	MSETTRK		;SET TK ADR = 0
	XRA	A		;SET FLAG = NO ERRORS
	RET
;
;	---SELECT DRIVE, HEAD, CYLINDER, AND SECTOR---
;
SLCT:	TFLG$	F$INIT		;CONTROLLER INITIALIZED?
	JNZ	SL0		;YES, GO ON
	CALL	INITD		;NO, INITIALIZE IT NOW
;
SL0:	LHLD	H$TRK		;REQUESTED TRACK
	MVI	A,MAXHED	;NUMBER OF HEADS
	CALL	DIVIDE		;HL/A ==> H = REMAINDER; L = QUOTIENT
	MOV	A,H
	MVI	H,0
	STA	RHD		;SAVE REAL HEAD #
	SHLD	RTK		;SAVE AS REAL TRACK#
	MOV	B,A
	LDA	H$DSK		;GET DRIVE NUMBER
	RLC			;SHIFT TO PROPER BITS
	RLC
	RLC
	ORA	B		;B = HEAD SLCT INFO
	OUT	WSDH		;SELECT HEAD 0...5, DRIVE
	MOV	A,H		;SEND TO CONTROLLER
	OUT	WHICYL
	MOV	A,L
	OUT	WLOCYL
	LDA	H$SEC		;SEND SECTOR NUMBER
	OUT	WSECT
	MVI	A,1		;SECTOR COUNT = 1
	OUT	WCOUNT
	RET
;
;	---DRIVE READY TEST---
;
RDY:	IN	WSTAT		;DRIVE STATUS
	ANI	WREADY		;DRIVE READY BIT
	XRI	WREADY		;INVERT IT
	RET			;IF A = 0, DRIVE RDY
;
;	---DISK ADDRESS COMPARE---
;
;   COMPARES EITHER THE HOST DISK ADDRESS OR THE UNALLOCATED
;   DISK ADDRESS AGAINST THE REQUESTED DISK ADDRESS.
;
;
DSKCMP: LXI	D,R$TRK 	;REQUESTED TRACK
	MVI	B,3
;
@D1A:	LDAX	D
	CMP	M
	RNZ			;RIF ADRS NOT EQUAL
	INX	H
	INX	D
	.Z80
	DJNZ	@D1A
	.8080
	RET

	PAGE
;	======================================
;	** SUBROUTINES, MESSAGES, & STORAGE **
;	======================================
;
;	---INITIALIZE FLAGS & VARIABLES---
;
INIT:	LXI	H,FLAGS
	MVI	B,FLGSIZ
	XRA	A
;
@I1A:	MOV	M,A		;CLEAR FLAGS & VARIABLES
	INX	H
	.Z80
	DJNZ	@I1A
	.8080
	LXI	H,0
INIT1:
	CALL	RDY
	RZ			;IF DRIVE READY THEN RETURN
	DCX	H
	MOV	A,H
	ORA	L
	JNZ	INIT1		;LOOP UNTIL READY OR TIME OUT
	RET
;
;	---SET FLAG BIT---
;
SETBIT: PUSH	H
	LXI	H,FLAGS 	;BIT FLAGS
	ORA	M		;OLD BITS
	MOV	M,A
	POP	H
	RET
;
;	---RESET BIT FLAG---
;
CLRBIT: PUSH	H
	LXI	H,FLAGS 	;BIT FLAGS
	ANA	M		;KILL UNWANTED BIT
	MOV	M,A
	POP	H
	RET
;
;	---TEST BIT FLAG---
;
TSTBIT: PUSH	H
	LXI	H,FLAGS 	;BIT FLAGS
	ANA	M		;TEST THE BIT
	POP	H
	RET
;
;	8-BITS BINARY DIVISION ROUTINE
;
DIVIDE:
	MOV	C,A		;SAVE DIVISOR INTO C-REG
	MVI	B,8		;COUNT = NUMBER OF BITS IN DIVISOR
DIV:
	DAD	H		;SHIFT DIVIDEND, QUOTIENT LEFT 1 BIT
	MOV	A,H		;CAN DIVISOR BE SUBTRACTED?
	SUB	C
	JC	CNT		;NO, GO TO NEXT STEP
	MOV	H,A		;YES, SUBTRACT DIVISOR FROM DIVIDENT
	INR	L		;ADD 1 TO QUOTIENT
CNT:
	DCR	B		;COUNT = COUNT -1
	JNZ	DIV		;LOOP UNTIL COUNT = 0
	RET			;RETURN WITH H = REMAINDER; L = QUOTIENT
;
;	---ERROR STATUS ROUTINE---
;
ERRORS:	IN	WSTAT		;WAIT FOR CONTROLLER NOT BUSY
	ANI	WBUSY
	JNZ	ERRORS
	IN	WSTAT		;GET PRIMARY STATUS
	STA	STAT
	IN	WERRS		;GET ERROR STATUS
	STA	ESTAT
	IN	WCOUNT		;GET RESIDUAL COUNT
	STA	RCT

	IF	RPTERRS		;IF ERROR REPORTING DESIRED:
	LDA	STAT
	ANI	WREADY		;DRIVE NOT READY?
	JNZ	@E0
	LXI	H,MSGNR
	CALL	PRNT
@E0:	LDA	STAT
	ANI	WFAULT		;WRITE FAULT?
	JZ	@E1
	LXI	H,MSGWF
	CALL	PRNT
@E1:	LDA	STAT
	ANI	WERROR		;ANY OTHER ERRORS?
	JZ	@E9		;NO, NO MORE MESSAGES
	LDA	ESTAT
	ANI	WEBLK		;BAD BLOCK?
	JZ	@E2
	LXI	H,MSGBB
	CALL	PRNT
@E2:	LDA	ESTAT
	ANI	WECRCD		;DATA CRC ERROR?
	JZ	@E3
	LXI	H,MSGCD
	CALL	PRNT
@E3:	LDA	ESTAT
	ANI	WECRCI		;ID CRC ERROR?
	JZ	@E4
	LXI	H,MSGCI
	CALL	PRNT
@E4:	LDA	ESTAT
	ANI	WENOT		;ID NOT FOUND?
	JZ	@E5
	LXI	H,MSGNF
	CALL	PRNT
@E5:	LDA	ESTAT
	ANI	WEABORT		;ABORTED COMMAND?
	JZ	@E6
	LXI	H,MSGAC
	CALL	PRNT
@E6:	LDA	ESTAT
	ANI	WETR0		;TRACK 000 ERROR?
	JZ	@E7
	LXI	H,MSGT0
	CALL	PRNT
@E7:	LDA	ESTAT
	ANI	WEDAM		;DATA ADDRESS MARK MISSING?
	JZ	@E9
	LXI	H,MSGDM
	CALL	PRNT
@E9:	LDA	STAT
	ANI	WREADY+WFAULT+WERROR	;ANY ERRORS?
	XRI	WREADY
	JZ	@EX
	LDA	RCM		;YES, PRINT COMMAND EXECUTED
	CPI	WREST
	JZ	@EA
	CPI	WREAD
	JZ	@EB
	CPI	WWRITE
	JZ	@EC
	LXI	H,MSGNC
	JMP	@EG
@EA:	LXI	H,MSGHC
	JMP	@EG
@EB:	LXI	H,MSGRC
	JMP	@EG
@EC:	LXI	H,MSGRC
@EG:	CALL	PRNT
	LDA	H$DSK
	MOV	E,A
	MVI	D,0
	LXI	H,MSG3D
	CALL	CVD1
	LHLD	RTK
	XCHG
	LXI	H,MSG3T
	CALL	CVD3
	LDA	RHD
	MOV	E,A
	MVI	D,0
	LXI	H,MSG3H
	CALL	CVD1
	LDA	H$SEC
	MOV	E,A
	MVI	D,0
	LXI	H,MSG3S
	CALL	CVD2
	LDA	RCT
	MOV	E,A
	MVI	D,0
	LXI	H,MSG3C
	CALL	CVD2
	LXI	H,MSG3
	CALL	PRNT
@EX:
	ENDIF

	LDA	STAT
	ANI	WFAULT+WERROR	;ANY ERRORS?
	RET
;
;	---DECIMAL CONVERSION SUBROUTINE---
;
	IF	RPTERRS
;
CVD3:	LXI	B,100
	CALL	CVD
CVD2:	LXI	B,10
	CALL	CVD
CVD1:	LXI	B,1
	CALL	CVD
	RET
;
CVD:	XRA	A		;CLEAR A
	XCHG			;SWAP DE(DATA) FOR HL(OUTPUT POINTER)
CVDL:	ORA	A		;CLEAR CARRY FLAG
	.Z80
	SBC	HL,BC		;SUBTRACT BC(POWER OF 10) FROM HL(DATA)
	.8080
	JM	CVDX		;IF RESULT NEGATIVE, EXIT
	INR	A		;POSITIVE, ADD ONE TO RESULT
	.Z80
	JR	CVDL
	.8080
;
CVDX:	DAD	B		;ADD BACK LAST VALUE
	XCHG			;SWAP BACK DE AND HL
	ADI	'0'		;CONVERT RESULT TO ASCII
	MOV	M,A		;STORE IN OUTPUT AREA
	INX	H		;BUMP OUTPUT POINTER
	RET			;RETURN TO CALLER
;
	ENDIF
;
;	---PRINT ROUTINE---
;
PRNT:	MOV	A,M		;PRINT CHAR
	INX	H		;FOR NEXT CHAR
	ORA	A
	RZ			;RIF DONE
	MOV	C,A
	PUSH	H
	CALL	CONOUT		;PRINT A CHAR
	POP	H
	JMP	PRNT		;DO NEXT CHAR
;
;	---CARRIAGE RETURN, LINE FEED----
;
CRLF:	MVI	C,CR
	CALL	CONOUT		;PRINT A CR
	MVI	C,LF
	JMP	CONOUT		;PRINT A LF, EXIT
;
;	---MESSAGES---
;
MSG1:	DB	CR,LF,BELL
	DB	'* Boot Failed -- Hit any key to retry'
	DB	CR,LF,0
;
MSG2:	DB	CR,LF,BELL
	DB	'* TM-603S Restore Failure -- Hit any key to retry, '
	DB	'Ctl-C to abort.'
	DB	CR,LF,0
;
	IF	RPTERRS
;
MSGNR:	DB	CR,LF,BELL
	DB	'* TM-603S Drive Not Ready.'
	DB	CR,LF,0
;
MSGWF:	DB	CR,LF,BELL
	DB	'* TM-603S Write Fault.'
	DB	CR,LF,0
;
MSGBB:	DB	CR,LF,BELL
	DB	'* TM-603S Bad Block Flag Detected.'
	DB	CR,LF,0
;
MSGCD:	DB	CR,LF,BELL
	DB	'* TM-603S CRC Error in Data.'
	DB	CR,LF,0
;
MSGCI:	DB	CR,LF,BELL
	DB	'* TM-603S CRC Error in ID Field.'
	DB	CR,LF,0
;
MSGNF:	DB	CR,LF,BELL
	DB	'* TM-603S Record Not Found.'
	DB	CR,LF,0
;
MSGAC:	DB	CR,LF,BELL
	DB	'* TM-603S Controller Aborted Command.  (Drive not responding)'
	DB	CR,LF,0
;
MSGT0:	DB	CR,LF,BELL
	DB	'* TM-603S Track 000 Error.'
	DB	CR,LF,0
;
MSGDM:	DB	CR,LF,BELL
	DB	'* TM-603S Data Address Mark Missing.'
	DB	CR,LF,0
;
MSGNC:	DB	CR,LF
	DB	'* TM-603S Error on UNKNOWN Command.'
	DB	CR,LF,0
;
MSGHC:	DB	CR,LF
	DB	'* TM-603S Error on Restore Command.'
	DB	CR,LF,0
;
MSGRC:	DB	CR,LF
	DB	'* TM-603S Error on Read Command.'
	DB	CR,LF,0
;
MSGWC:	DB	CR,LF
	DB	'* TM-603S Error on Write Command.'
	DB	CR,LF,0
;
MSG3:	DB	CR,LF
	DB	'* TM-603S Error on Drive '
MSG3D:	DB	'9'
	DB	' at Cylinder = '
MSG3T:	DB	'999'
	DB	', Head = '
MSG3H:	DB	'9'
	DB	', Sector = '
MSG3S:	DB	'99'
	DB	', Count = '
MSG3C:	DB	'99'
	DB	'.'
	DB	CR,LF,0
;
	ENDIF
;
;	--- DISK INITIALIZATION ---
;
INITD:	SFLG$	F$INIT		;SET FLAG TO SAY INTIALIZED
	CALL	SL0		;SELECT PROPER DRIVE
	MVI	A,PCMPCYL/4	;SET PRECOMP CYLINDER
	OUT	WPCYL
	XRA	A		;SELECT TRACK 0, HEAD 0
	STA	RHD
	LXI	H,0
	SHLD	RTK
	LDA	RCM		;LAST COMMAND
	STA	SAVRCM		;SAVE IT
	MVI	A,WREST		;RESTORE COMMAND
	STA	RCM
	OUT	WCMD
	CALL	ERRORS		;WAIT TILL DONE
	LDA	SAVRCM		;SAVED COMMAND
	STA	RCM		;PUT IT BACK
	RZ			;RETURN IF NO ERRORS
;
	LXI	H,MSG2		;YES, TELL OPERATOR
	CALL	PRNT
	CALL	CONIN		;WAIT FOR REPLY
	CPI	CTLC		;CTL-C?
	RZ			;YES, IGNORE THIS DRIVE
	CALL	CRLF		;NO, NEW LINE, THEN RETRY
	JMP	INITD

CODEND	EQU	$		;DEFINES END OF CODE

	PAGE
;
;	---PROGRAM STORAGE---
;
FLAGS:	DS	1		;BIT FLAGS
;
R$TRK:	DS	2		;REQUESTED TRACK ADDRESS
R$DSK:	DS	1		;   DRIVE #
R$SEC:	DS	1		;   SECTOR ADDRESS (CP/M)
;
U$TRK:	DS	2		;UNALLOCATED TRACK ADDRESS
U$DSK:	DS	1		;   DRIVE #
U$SEC:	DS	1		;   SECTOR ADDRESS
U$CNT:	DS	1		;   RECORD COUNT
;
H$TRK:	DS	2		;HOST (SHUGART) TRACK ADDRESS
H$DSK:	DS	1		;   DRIVE #
H$SEC:	DS	1		;   SECTOR ADDRESS (REAL)
;
RTK:	DS	2		;REAL TRACK ADDRESS
RHD:	DS	1		;  HEAD
RSA:	DS	1		;  SECTOR
RCT:	DS	1		;  SECTOR COUNT
RCM:	DS	1		;LAST COMMAND ISSUED
SAVRCM:	DS	1		;SAVE AREA FOR RCM
;
SECNT:	DS	1		;SECTOR COUNT (FOR WARM BOOT)
RETRY:	DS	1		;RETRY COUNT
STAT:	DS	1		;STATUS BYTE
ESTAT:	DS	1		;ERROR STATUS BYTE
ERFLG:	DS	1		;ERROR FLAG
DMADR:	DS	2		;BUFFER (DMA) ADDRESS
WRTMODE: DS	1		;WRITE MODE
ERRCNT:	DS	1		;ERROR RETRY COUNT
BLKMSK:	DS	1		;STORAGE FOR BLOCK MASK
;
FLGSIZ	EQU	$-FLAGS 	;DEFINES SIZE OF VARIABLE STORAGE
;
LOGDSKN:
	DB	0		;0 = LOGICAL DISK SELECT #0
				;1 = LOGICAL DISK SELECT #1

SECTOR:	DS	256		;LOCAL SECTOR BUFFER
;
;	---BDOS STORAGE---
;
;
DIRBFR: DS	128		;DIRECTORY BUFFER
HALL0:	DS	(DSM0/8)+1	;TM-603S BIT MAP
HALL1:	DS	(DSM1/8)+1	;BIT MAP FOR LOGICAL DRIVE #1
HALL2:	DS	(DSM2/8)+1	;BIT MAP FOR LOGICAL DRIVE #2
;
LAST:	DB	55H		;DEFINES END OF PROGRAM
;
;	END
